/**
 * Integration tests — Full compilation pipeline from parse → link → verify → emit.
 */

import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { parseGlassFile, parseGlassContent } from "../../src/compiler/parser";
import { linkIntentTree } from "../../src/compiler/linker";
import { verifyContract, verifyAll } from "../../src/compiler/verifier";
import { emitTypeScript } from "../../src/compiler/emitter";
import { generateAllViews } from "../../src/compiler/view-generator";
import type { GlassFile, VerificationResult } from "../../src/types/index";

describe("Full Pipeline Integration", () => {
  const fixturesDir = path.join(__dirname, "..", "fixtures", "valid-glass-files");
  let tempDir: string;

  beforeEach(() => {
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "glass-pipeline-"));
  });

  afterEach(() => {
    fs.rmSync(tempDir, { recursive: true, force: true });
  });

  it("should parse, link, verify, and emit a single file", () => {
    // Use sanitize_input which has no sub-intent references
    const file = path.join(fixturesDir, "auth.sanitize_input.glass");
    const parseResult = parseGlassFile(file);
    expect(parseResult.ok).toBe(true);
    if (!parseResult.ok) return;

    const glassFile = parseResult.value;
    expect(glassFile.id).toBe("auth.sanitize_input");

    // Override parent to null so it can stand alone
    const standalone: GlassFile = {
      ...glassFile,
      intent: { ...glassFile.intent, parent: null },
    };

    // Link (single file with no sub-intent refs)
    const linkResult = linkIntentTree([standalone]);
    expect(linkResult.ok).toBe(true);
    if (!linkResult.ok) return;
    expect(linkResult.value.roots).toContain("auth.sanitize_input");

    // Verify
    const verifyResult = verifyContract(standalone);
    expect(verifyResult.status).toBe("PROVEN");

    // Emit
    const outputDir = path.join(tempDir, "dist");
    const verificationResults = new Map<string, VerificationResult>();
    verificationResults.set(standalone.id, verifyResult);

    const emitResult = emitTypeScript([standalone], verificationResults, outputDir);
    expect(emitResult.ok).toBe(true);
    if (!emitResult.ok) return;
    expect(emitResult.value.length).toBeGreaterThan(0);

    // Check emitted file exists
    const emittedFile = path.join(outputDir, "auth", "sanitize_input.ts");
    expect(fs.existsSync(emittedFile)).toBe(true);
    const content = fs.readFileSync(emittedFile, "utf-8");
    expect(content).toContain("Generated by Glass Compiler");
  });

  it("should parse, link, and verify a multi-file hierarchy", () => {
    // Build a clean hierarchy in-memory with proper parent/child refs
    const root: GlassFile = {
      id: "app.root",
      version: "0.1.0",
      language: "typescript",
      intent: {
        purpose: "Root application module",
        source: { kind: "prd", reference: "Section 1" },
        parent: null,
        stakeholder: "user",
        subIntents: [{ id: "app.child_a" }, { id: "app.child_b" }],
        approvalStatus: "approved",
      },
      contract: {
        requires: [{ description: "config is provided" }],
        guarantees: { onSuccess: [{ description: "App is initialized" }], onFailure: [] },
        invariants: [],
        fails: [],
        advisories: [],
      },
      implementation: 'export function init(config: any) { return { initialized: true, config }; }',
    };

    const childA: GlassFile = {
      id: "app.child_a",
      version: "0.1.0",
      language: "typescript",
      intent: {
        purpose: "Child module A",
        source: { kind: "conversation", sessionId: "1" },
        parent: "app.root",
        stakeholder: "engineering",
        subIntents: [],
        approvalStatus: "approved",
      },
      contract: {
        requires: [{ description: "input is a string" }],
        guarantees: { onSuccess: [{ description: "Returns processed string" }], onFailure: [] },
        invariants: [],
        fails: [],
        advisories: [],
      },
      implementation: 'export function processA(input: string) { return input.toUpperCase(); }',
    };

    const childB: GlassFile = {
      id: "app.child_b",
      version: "0.1.0",
      language: "typescript",
      intent: {
        purpose: "Child module B",
        source: { kind: "ai-generated", reason: "security" },
        parent: "app.root",
        stakeholder: "security",
        subIntents: [],
        approvalStatus: "auto-approved",
      },
      contract: {
        requires: [{ description: "data is not null" }],
        guarantees: { onSuccess: [{ description: "Returns sanitized data" }], onFailure: [] },
        invariants: [],
        fails: [],
        advisories: [],
      },
      implementation: 'export function processB(data: any) { return data; }',
    };

    const files = [root, childA, childB];

    // Link
    const linkResult = linkIntentTree(files);
    expect(linkResult.ok).toBe(true);
    if (!linkResult.ok) return;

    const tree = linkResult.value;
    expect(tree.roots).toEqual(["app.root"]);
    expect(tree.childrenMap.get("app.root")).toEqual(["app.child_a", "app.child_b"]);

    // Verify all
    const results = verifyAll(files);
    expect(results.size).toBe(3);
    for (const [, result] of results) {
      expect(result.status).toBe("PROVEN");
    }
  });

  it("should generate views from a verified project", () => {
    const files: GlassFile[] = [];
    const fixtureFiles = fs.readdirSync(fixturesDir).filter((f) => f.endsWith(".glass"));
    for (const f of fixtureFiles) {
      const result = parseGlassFile(path.join(fixturesDir, f));
      if (result.ok) files.push(result.value);
    }

    const linkResult = linkIntentTree(files);
    if (!linkResult.ok) return;

    const verificationResults = new Map<string, VerificationResult>();
    for (const file of files) {
      verificationResults.set(file.id, verifyContract(file));
    }

    const viewsDir = path.join(tempDir, "glass-views");
    const viewResult = generateAllViews(files, linkResult.value, verificationResults, viewsDir);
    expect(viewResult.ok).toBe(true);
    if (!viewResult.ok) return;

    // Check view files exist
    expect(fs.existsSync(viewsDir)).toBe(true);
    const viewFiles = fs.readdirSync(viewsDir);
    expect(viewFiles.length).toBeGreaterThan(0);
  });

  it("should reject emission for failed verification", () => {
    // Create a file that will fail verification
    const content = `=== Glass Unit ===
id: test.failing
version: 0.1.0
language: typescript

=== Intent ===
purpose: Test failing verification
source:
  kind: prd
  reference: "test"
parent: null
stakeholder: engineering
subIntents: []
approvalStatus: approved

=== Contract ===
requires:
  - "input is a valid User object"
guarantees:
  on_success:
    - "Returns processed result"
  on_failure: []
invariants: []
fails:
  - NetworkError: "retry(3) then Error(ServiceUnavailable)"
advisories: []

=== Implementation ===
export function failing() {
  return "no input parameter used at all";
}
`;

    const parseResult = parseGlassContent(content, "test.glass");
    expect(parseResult.ok).toBe(true);
    if (!parseResult.ok) return;

    const file = parseResult.value;
    const verifyResult = verifyContract(file);

    // This should fail due to missing input reference and unhandled failure
    expect(verifyResult.status).toBe("FAILED");

    // Emit should refuse
    const outputDir = path.join(tempDir, "dist");
    const verificationResults = new Map<string, VerificationResult>();
    verificationResults.set(file.id, verifyResult);

    const emitResult = emitTypeScript([file], verificationResults, outputDir);
    expect(emitResult.ok).toBe(false);
  });

  it("should handle parse errors gracefully", () => {
    const invalidDir = path.join(__dirname, "..", "fixtures", "invalid-glass-files");

    const malformed = parseGlassFile(path.join(invalidDir, "malformed-header.glass"));
    expect(malformed.ok).toBe(false);
    if (malformed.ok) return;
    expect(malformed.error.reason).toBe("MissingSection");

    const missingIntent = parseGlassFile(path.join(invalidDir, "missing-intent.glass"));
    expect(missingIntent.ok).toBe(false);
    if (missingIntent.ok) return;
    expect(missingIntent.error.reason).toBe("MissingSection");

    const missingContract = parseGlassFile(path.join(invalidDir, "missing-contract.glass"));
    expect(missingContract.ok).toBe(false);
    if (missingContract.ok) return;
    expect(missingContract.error.reason).toBe("MissingSection");

    const missingImpl = parseGlassFile(path.join(invalidDir, "missing-implementation.glass"));
    expect(missingImpl.ok).toBe(false);
    if (missingImpl.ok) return;
    expect(missingImpl.error.reason).toBe("MissingSection");
  });

  it("should detect dangling parent references", () => {
    const fileA: GlassFile = {
      id: "orphan.child",
      version: "0.1.0",
      language: "typescript",
      intent: {
        purpose: "Child with missing parent",
        source: { kind: "prd", reference: "test" },
        parent: "nonexistent.parent",
        stakeholder: "engineering",
        subIntents: [],
        approvalStatus: "approved",
      },
      contract: {
        requires: [],
        guarantees: { onSuccess: [], onFailure: [] },
        invariants: [],
        fails: [],
        advisories: [],
      },
      implementation: "export function a() {}",
    };

    const linkResult = linkIntentTree([fileA]);
    expect(linkResult.ok).toBe(false);
    if (linkResult.ok) return;
    expect(linkResult.error.reason).toBe("DanglingReference");
  });

  it("should handle full pipeline for emitting multiple units", () => {
    const files: GlassFile[] = [];
    const fixtureFiles = fs.readdirSync(fixturesDir).filter((f) => f.endsWith(".glass"));
    for (const f of fixtureFiles) {
      const result = parseGlassFile(path.join(fixturesDir, f));
      if (result.ok) files.push(result.value);
    }

    const linkResult = linkIntentTree(files);
    if (!linkResult.ok) return;

    const verificationResults = new Map<string, VerificationResult>();
    for (const file of files) {
      verificationResults.set(file.id, verifyContract(file));
    }

    // Only emit verified files
    const verifiedFiles = files.filter((f) => {
      const r = verificationResults.get(f.id);
      return r && r.status === "PROVEN";
    });

    const outputDir = path.join(tempDir, "dist");
    const verifiedResults = new Map<string, VerificationResult>();
    for (const f of verifiedFiles) {
      const r = verificationResults.get(f.id);
      if (r) verifiedResults.set(f.id, r);
    }

    const emitResult = emitTypeScript(verifiedFiles, verifiedResults, outputDir);
    expect(emitResult.ok).toBe(true);
    if (!emitResult.ok) return;
    expect(emitResult.value.length).toBe(verifiedFiles.length);
  });
});
