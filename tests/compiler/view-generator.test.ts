import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import {
  generateIntentOutline,
  generateContractOutline,
  generateVerificationChecklist,
  generateBusinessView,
  generateSecurityView,
  generateVerificationDashboard,
  generateAllViews,
} from "../../src/compiler/view-generator";
import { linkIntentTree } from "../../src/compiler/linker";
import { verifyContract } from "../../src/compiler/verifier";
import type { GlassFile, VerificationResult, IntentTree } from "../../src/types/index";

function makeFile(overrides: Partial<GlassFile> & { id: string }): GlassFile {
  return {
    version: "0.1.0",
    language: "typescript",
    intent: {
      purpose: "Test unit " + overrides.id,
      source: { kind: "prd", reference: "test" },
      parent: null,
      stakeholder: "engineering",
      subIntents: [],
      approvalStatus: "approved",
    },
    contract: {
      requires: [],
      guarantees: { onSuccess: [], onFailure: [] },
      invariants: [],
      fails: [],
      advisories: [],
    },
    implementation: "// stub",
    ...overrides,
  };
}

function makeTempDir(): string {
  return fs.mkdtempSync(path.join(os.tmpdir(), "glass-views-test-"));
}

function cleanupDir(dir: string) {
  try { fs.rmSync(dir, { recursive: true, force: true }); } catch { /* ignore */ }
}

describe("View Generator", () => {
  describe("generateIntentOutline", () => {
    it("should generate valid markdown with purpose and source", () => {
      const file = makeFile({
        id: "auth.login",
        intent: {
          purpose: "Allow users to log in",
          source: { kind: "prd", reference: "Section 3" },
          parent: "auth",
          stakeholder: "user",
          subIntents: [
            { id: "auth.validate" },
            { id: "auth.sanitize", annotations: ["ai-generated", "security"] },
          ],
          approvalStatus: "approved",
        },
      });

      const md = generateIntentOutline(file);
      expect(md).toContain("# Intent: auth.login");
      expect(md).toContain("Allow users to log in");
      expect(md).toContain("PRD");
      expect(md).toContain("user");
      expect(md).toContain("auth.validate");
      expect(md).toContain("ai-generated, security");
      expect(md).toContain("Auto-generated by Glass");
    });
  });

  describe("generateContractOutline", () => {
    it("should include all contract sections", () => {
      const file = makeFile({
        id: "auth.login",
        contract: {
          requires: [{ description: "input.email is String" }],
          guarantees: {
            onSuccess: [{ description: "result is AuthSuccess" }],
            onFailure: [{ description: "result is AuthFailure" }],
          },
          invariants: [{ description: "password never exposed" }],
          fails: [{ errorType: "DatabaseError", handling: "retry(3)" }],
          advisories: [{ description: "fail-open policy", resolved: false }],
        },
      });

      const md = generateContractOutline(file);
      expect(md).toContain("# Contract: auth.login");
      expect(md).toContain("input.email is String");
      expect(md).toContain("result is AuthSuccess");
      expect(md).toContain("result is AuthFailure");
      expect(md).toContain("password never exposed");
      expect(md).toContain("DatabaseError");
      expect(md).toContain("fail-open policy");
      expect(md).toContain("[OPEN]");
    });
  });

  describe("generateVerificationChecklist", () => {
    it("should show pass/fail status for each assertion", () => {
      const result: VerificationResult = {
        unitId: "auth.login",
        status: "PROVEN",
        assertions: [
          { assertion: "input used", passed: true, level: "PROVEN", message: "Found in code" },
          { assertion: "system check", passed: true, level: "INSTRUMENTED", message: "Runtime" },
        ],
        advisories: [{ description: "Advisory note", resolved: false }],
      };

      const md = generateVerificationChecklist(result);
      expect(md).toContain("# Verification: auth.login");
      expect(md).toContain("PROVEN");
      expect(md).toContain("2/2 passed");
      expect(md).toContain("input used");
      expect(md).toContain("Advisory note");
    });

    it("should show failures", () => {
      const result: VerificationResult = {
        unitId: "test.fail",
        status: "FAILED",
        assertions: [
          { assertion: "missing handler", passed: false, level: "TESTED", message: "Not found" },
        ],
        advisories: [],
      };

      const md = generateVerificationChecklist(result);
      expect(md).toContain("FAILED");
      expect(md).toContain("0/1 passed");
      expect(md).toContain("[x]");
    });
  });

  describe("generateBusinessView", () => {
    it("should render intent tree in non-technical format", () => {
      const files = [
        makeFile({
          id: "auth",
          intent: {
            purpose: "Allow users to securely access the system",
            source: { kind: "prd", reference: "Section 3" },
            parent: null,
            stakeholder: "user",
            subIntents: [],
            approvalStatus: "approved",
          },
        }),
        makeFile({
          id: "auth.login",
          intent: {
            purpose: "Log users into the system",
            source: { kind: "conversation", sessionId: "s1" },
            parent: "auth",
            stakeholder: "user",
            subIntents: [],
            approvalStatus: "approved",
          },
        }),
      ];

      const treeResult = linkIntentTree(files);
      expect(treeResult.ok).toBe(true);
      if (!treeResult.ok) return;

      const md = generateBusinessView(treeResult.value);
      expect(md).toContain("# Business View");
      expect(md).toContain("Allow users to securely access the system");
      expect(md).toContain("Log users into the system");
      expect(md).toContain("PRD");
      expect(md).toContain("conversation");
    });
  });

  describe("generateSecurityView", () => {
    it("should highlight security invariants", () => {
      const files = [
        makeFile({
          id: "auth.login",
          contract: {
            requires: [],
            guarantees: { onSuccess: [], onFailure: [] },
            invariants: [
              { description: "password_hash never exposed in logs" },
              { description: "rate_limit correctly updated" },
            ],
            fails: [],
            advisories: [{ description: "uses fail-open rate limiting", resolved: false }],
          },
          implementation: "// safe code",
        }),
      ];

      const results = new Map<string, VerificationResult>();
      results.set("auth.login", verifyContract(files[0]));

      const md = generateSecurityView(files, results);
      expect(md).toContain("# Security View");
      expect(md).toContain("password_hash never exposed");
      expect(md).toContain("fail-open");
    });
  });

  describe("generateVerificationDashboard", () => {
    it("should show summary statistics and per-unit status", () => {
      const results = new Map<string, VerificationResult>();
      results.set("auth.login", {
        unitId: "auth.login",
        status: "PROVEN",
        assertions: [
          { assertion: "a1", passed: true, level: "PROVEN", message: "ok" },
          { assertion: "a2", passed: true, level: "PROVEN", message: "ok" },
        ],
        advisories: [],
      });
      results.set("auth.logout", {
        unitId: "auth.logout",
        status: "FAILED",
        assertions: [
          { assertion: "a3", passed: false, level: "TESTED", message: "fail" },
        ],
        advisories: [],
      });

      const md = generateVerificationDashboard(results);
      expect(md).toContain("# Verification Dashboard");
      expect(md).toContain("Total Units | 2");
      expect(md).toContain("Verified (PROVEN) | 1");
      expect(md).toContain("Failed | 1");
      expect(md).toContain("auth.login");
      expect(md).toContain("auth.logout");
    });
  });

  describe("generateAllViews", () => {
    let tempDir: string;

    beforeEach(() => {
      tempDir = makeTempDir();
    });

    afterEach(() => {
      cleanupDir(tempDir);
    });

    it("should write all view files to the output directory", () => {
      const files = [makeFile({ id: "test.unit" })];
      const treeResult = linkIntentTree(files);
      expect(treeResult.ok).toBe(true);
      if (!treeResult.ok) return;

      const results = new Map<string, VerificationResult>();
      results.set("test.unit", verifyContract(files[0]));

      const outputDir = path.join(tempDir, ".generated");
      const viewResult = generateAllViews(files, treeResult.value, results, outputDir);
      expect(viewResult.ok).toBe(true);
      if (!viewResult.ok) return;

      // Per-unit views
      expect(fs.existsSync(path.join(outputDir, "units", "test_unit.intent.md"))).toBe(true);
      expect(fs.existsSync(path.join(outputDir, "units", "test_unit.contract.md"))).toBe(true);
      expect(fs.existsSync(path.join(outputDir, "units", "test_unit.verification.md"))).toBe(true);

      // Aggregate views
      expect(fs.existsSync(path.join(outputDir, "business-view.md"))).toBe(true);
      expect(fs.existsSync(path.join(outputDir, "security-view.md"))).toBe(true);
      expect(fs.existsSync(path.join(outputDir, "verification-dashboard.md"))).toBe(true);
      expect(fs.existsSync(path.join(outputDir, "master-intent-outline.md"))).toBe(true);
      expect(fs.existsSync(path.join(outputDir, "master-contract-outline.md"))).toBe(true);

      // All files should have auto-generated header
      const content = fs.readFileSync(path.join(outputDir, "business-view.md"), "utf-8");
      expect(content).toContain("Auto-generated by Glass");
    });
  });
});
