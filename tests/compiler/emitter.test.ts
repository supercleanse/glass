import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { emitTypeScript, mapGlassIdToPath, emitWithOptions } from "../../src/compiler/emitter";
import { verifyContract } from "../../src/compiler/verifier";
import type { GlassFile, VerificationResult } from "../../src/types/index";

/** Helper to build a minimal GlassFile for testing. */
function makeFile(overrides: Partial<GlassFile> & { id: string }): GlassFile {
  return {
    version: "0.1.0",
    language: "typescript",
    intent: {
      purpose: "Test unit " + overrides.id,
      source: { kind: "prd", reference: "test" },
      parent: null,
      stakeholder: "engineering",
      subIntents: [],
      approvalStatus: "approved",
    },
    contract: {
      requires: [],
      guarantees: { onSuccess: [], onFailure: [] },
      invariants: [],
      fails: [],
      advisories: [],
    },
    implementation: 'export function stub() { return true; }',
    specPath: "/test/" + overrides.id.replace(/\./g, "/") + ".glass",
    implementationPath: null,
    separatedFormat: false,
    ...overrides,
  };
}

/** Create a temp directory for test output. */
function makeTempDir(): string {
  return fs.mkdtempSync(path.join(os.tmpdir(), "glass-emitter-test-"));
}

/** Clean up a temp directory. */
function cleanupDir(dir: string) {
  try {
    fs.rmSync(dir, { recursive: true, force: true });
  } catch { /* ignore */ }
}

/** Build verification results for files (all passing). */
function makeVerificationResults(files: GlassFile[]): Map<string, VerificationResult> {
  const results = new Map<string, VerificationResult>();
  for (const file of files) {
    results.set(file.id, verifyContract(file));
  }
  return results;
}

describe("TypeScript Emitter", () => {
  describe("mapGlassIdToPath", () => {
    it("should convert dotted ID to file path", () => {
      const result = mapGlassIdToPath("auth.authenticate_user", "dist");
      expect(result).toMatch(/dist[/\\]auth[/\\]authenticate_user\.ts$/);
    });

    it("should handle single-segment ID", () => {
      const result = mapGlassIdToPath("index", "dist");
      expect(result).toMatch(/dist[/\\]index\.ts$/);
    });

    it("should handle deeply nested ID", () => {
      const result = mapGlassIdToPath("auth.user.session.create", "dist");
      expect(result).toMatch(/dist[/\\]auth[/\\]user[/\\]session[/\\]create\.ts$/);
    });
  });

  describe("emitTypeScript", () => {
    let tempDir: string;

    beforeEach(() => {
      tempDir = makeTempDir();
    });

    afterEach(() => {
      cleanupDir(tempDir);
    });

    it("should emit a single file with header", () => {
      const files = [makeFile({ id: "test.simple" })];
      const results = makeVerificationResults(files);
      const outputDir = path.join(tempDir, "dist");

      const emitResult = emitTypeScript(files, results, outputDir);
      expect(emitResult.ok).toBe(true);
      if (!emitResult.ok) return;

      expect(emitResult.value).toHaveLength(1);

      const outputPath = emitResult.value[0];
      expect(fs.existsSync(outputPath)).toBe(true);

      const content = fs.readFileSync(outputPath, "utf-8");
      expect(content).toContain("Generated by Glass Compiler");
      expect(content).toContain("test.simple");
      expect(content).toContain("export function stub()");
    });

    it("should generate tsconfig.json", () => {
      const files = [makeFile({ id: "test.config" })];
      const results = makeVerificationResults(files);
      const outputDir = path.join(tempDir, "dist");

      const emitResult = emitTypeScript(files, results, outputDir);
      expect(emitResult.ok).toBe(true);

      const tsconfigPath = path.join(outputDir, "tsconfig.json");
      expect(fs.existsSync(tsconfigPath)).toBe(true);

      const tsconfig = JSON.parse(fs.readFileSync(tsconfigPath, "utf-8"));
      expect(tsconfig.compilerOptions.target).toBe("ES2020");
      expect(tsconfig.compilerOptions.strict).toBe(true);
      expect(tsconfig.compilerOptions.declaration).toBe(true);
      expect(tsconfig.include).toContain("**/*.ts");
    });

    it("should generate package.json", () => {
      const files = [makeFile({ id: "test.pkg" })];
      const results = makeVerificationResults(files);
      const outputDir = path.join(tempDir, "dist");

      const emitResult = emitTypeScript(files, results, outputDir, {
        projectName: "My Test Project",
        projectVersion: "1.0.0",
      });
      expect(emitResult.ok).toBe(true);

      const pkgPath = path.join(outputDir, "package.json");
      expect(fs.existsSync(pkgPath)).toBe(true);

      const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
      expect(pkg.name).toBe("my-test-project");
      expect(pkg.version).toBe("1.0.0");
      expect(pkg.scripts.build).toBe("tsc");
      expect(pkg.devDependencies.typescript).toBeDefined();
    });

    it("should refuse to emit when verification is missing", () => {
      const files = [makeFile({ id: "test.missing" })];
      const results = new Map<string, VerificationResult>();
      const outputDir = path.join(tempDir, "dist");

      const emitResult = emitTypeScript(files, results, outputDir);
      expect(emitResult.ok).toBe(false);
      if (emitResult.ok) return;

      expect(emitResult.error.reason).toBe("VerificationNotPassed");
      expect(emitResult.error.unitId).toBe("test.missing");

      // No files should have been written
      expect(fs.existsSync(outputDir)).toBe(false);
    });

    it("should refuse to emit when verification failed", () => {
      const files = [makeFile({
        id: "test.failed",
        contract: {
          requires: [{ description: "input.token is String" }],
          guarantees: { onSuccess: [], onFailure: [] },
          invariants: [],
          fails: [],
          advisories: [],
        },
        implementation: "function noInputs() { return true; }",
      })];

      const results = makeVerificationResults(files);
      // Verify it actually failed
      expect(results.get("test.failed")!.status).toBe("FAILED");

      const outputDir = path.join(tempDir, "dist");
      const emitResult = emitTypeScript(files, results, outputDir);
      expect(emitResult.ok).toBe(false);
      if (emitResult.ok) return;

      expect(emitResult.error.reason).toBe("VerificationNotPassed");
    });

    it("should emit multiple files", () => {
      const files = [
        makeFile({ id: "auth.login" }),
        makeFile({ id: "auth.logout" }),
        makeFile({ id: "billing.charge" }),
      ];
      const results = makeVerificationResults(files);
      const outputDir = path.join(tempDir, "dist");

      const emitResult = emitTypeScript(files, results, outputDir);
      expect(emitResult.ok).toBe(true);
      if (!emitResult.ok) return;

      expect(emitResult.value).toHaveLength(3);
      for (const outputPath of emitResult.value) {
        expect(fs.existsSync(outputPath)).toBe(true);
      }

      // Check directory structure
      expect(fs.existsSync(path.join(outputDir, "auth"))).toBe(true);
      expect(fs.existsSync(path.join(outputDir, "billing"))).toBe(true);
    });

    it("should collect external dependencies in package.json", () => {
      const files = [makeFile({
        id: "test.deps",
        implementation: `import bcrypt from "bcrypt";\nimport express from "express";\nexport function hash(pw: string) { return bcrypt.hash(pw, 10); }`,
      })];
      const results = makeVerificationResults(files);
      const outputDir = path.join(tempDir, "dist");

      const emitResult = emitTypeScript(files, results, outputDir);
      expect(emitResult.ok).toBe(true);

      const pkg = JSON.parse(fs.readFileSync(path.join(outputDir, "package.json"), "utf-8"));
      expect(pkg.dependencies.bcrypt).toBeDefined();
      expect(pkg.dependencies.express).toBeDefined();
    });

    it("should clean output directory when cleanOutput is true", () => {
      const outputDir = path.join(tempDir, "dist");
      fs.mkdirSync(outputDir, { recursive: true });
      fs.writeFileSync(path.join(outputDir, "old-file.txt"), "old content");

      const files = [makeFile({ id: "test.clean" })];
      const results = makeVerificationResults(files);

      const emitResult = emitTypeScript(files, results, outputDir, { cleanOutput: true });
      expect(emitResult.ok).toBe(true);

      // Old file should be gone
      expect(fs.existsSync(path.join(outputDir, "old-file.txt"))).toBe(false);
      // New files should exist
      expect(fs.existsSync(path.join(outputDir, "tsconfig.json"))).toBe(true);
    });

    it("should not modify input GlassFile objects", () => {
      const files = [makeFile({ id: "test.immutable" })];
      const original = JSON.parse(JSON.stringify(files));
      const results = makeVerificationResults(files);
      const outputDir = path.join(tempDir, "dist");

      emitTypeScript(files, results, outputDir);

      // Compare using JSON since GlassFile is a plain object
      expect(JSON.stringify(files)).toBe(JSON.stringify(original));
    });

    it("should handle empty file list", () => {
      const files: GlassFile[] = [];
      const results = new Map<string, VerificationResult>();
      const outputDir = path.join(tempDir, "dist");

      const emitResult = emitTypeScript(files, results, outputDir);
      expect(emitResult.ok).toBe(true);
      if (!emitResult.ok) return;

      expect(emitResult.value).toHaveLength(0);
      // Config files should still be generated
      expect(fs.existsSync(path.join(outputDir, "tsconfig.json"))).toBe(true);
      expect(fs.existsSync(path.join(outputDir, "package.json"))).toBe(true);
    });
  });

  describe("emitWithOptions", () => {
    let tempDir: string;

    beforeEach(() => {
      tempDir = makeTempDir();
    });

    afterEach(() => {
      cleanupDir(tempDir);
    });

    it("should work with options object", () => {
      const files = [makeFile({ id: "test.options" })];
      const results = makeVerificationResults(files);
      const outputDir = path.join(tempDir, "dist");

      const emitResult = emitWithOptions({
        files,
        verificationResults: results,
        outputDir,
        projectName: "test-project",
        projectVersion: "2.0.0",
      });

      expect(emitResult.ok).toBe(true);
      if (!emitResult.ok) return;

      const pkg = JSON.parse(fs.readFileSync(path.join(outputDir, "package.json"), "utf-8"));
      expect(pkg.name).toBe("test-project");
      expect(pkg.version).toBe("2.0.0");
    });
  });
});
