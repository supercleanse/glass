=== Glass Unit ===
id: compiler.ast_verifier
version: 0.1.0
language: typescript

=== Intent ===
purpose: Provide AST-based contract verification using the TypeScript Compiler API for PROVEN-level assertions
source:
  kind: prd
  reference: "Verifier Phase 2 PRD — AST-Based Contract Verification"
parent: glass.compiler
stakeholder: engineering
subIntents: []
approvalStatus: approved

=== Contract ===
requires:
  - "file is a valid GlassFile with contract and implementation"
  - "program is a valid ts.Program with type checker"

guarantees:
  on_success:
    - "verifyGuaranteesWithAST proves return types via type checker"
    - "verifyRequiresWithAST proves parameter types via type checker"
    - "verifyFailureModesWithAST finds Err() calls, throw statements, catch clauses via AST"
    - "verifyInvariantsWithAST detects mutation, sensitive data exposure, determinism, statelessness"
  on_failure:
    - "Returns empty assertions array if source file not found in program"

invariants:
  - "Implementation code is never modified"
  - "Verification is deterministic — same input produces same output"

fails:

advisories:

=== Implementation ===
/**
 * AST-Based Contract Verification (Phase 2)
 *
 * Uses the TypeScript Compiler API for semantic analysis instead of
 * regex pattern matching. Provides PROVEN-level assertions for:
 * - Return type guarantees (via type checker)
 * - Parameter type requires (via type checker)
 * - Error handling coverage (via AST traversal of Err/throw/catch)
 * - Invariant verification (via mutation and exposure analysis)
 */

import * as ts from "typescript";
import type { GlassFile, VerificationAssertion } from "../types/index";
import { getVirtualPath } from "./ts-program-factory";

// ============================================================
// AST Traversal Utilities
// ============================================================

/** Find all exported function declarations in a source file. */
function findExportedFunctions(sourceFile: ts.SourceFile): ts.FunctionDeclaration[] {
  const results: ts.FunctionDeclaration[] = [];
  ts.forEachChild(sourceFile, (node) => {
    if (
      ts.isFunctionDeclaration(node) &&
      node.name &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      results.push(node);
    }
  });
  return results;
}

/** Find all exported variable declarations (const/let with export). */
function findExportedVariables(sourceFile: ts.SourceFile): ts.VariableDeclaration[] {
  const results: ts.VariableDeclaration[] = [];
  ts.forEachChild(sourceFile, (node) => {
    if (
      ts.isVariableStatement(node) &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      for (const decl of node.declarationList.declarations) {
        results.push(decl);
      }
    }
  });
  return results;
}

/** Find all exported interfaces and type aliases. */
function findExportedTypes(sourceFile: ts.SourceFile): string[] {
  const names: string[] = [];
  ts.forEachChild(sourceFile, (node) => {
    if (
      (ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)) &&
      node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)
    ) {
      names.push(node.name.text);
    }
  });
  return names;
}

/** Recursively collect all nodes matching a predicate. */
function collectNodes<T extends ts.Node>(
  root: ts.Node,
  predicate: (node: ts.Node) => node is T,
): T[] {
  const results: T[] = [];
  function visit(node: ts.Node): void {
    if (predicate(node)) results.push(node);
    ts.forEachChild(node, visit);
  }
  visit(root);
  return results;
}

/** Check if a type string contains a given type name (handles generics, unions). */
function typeContains(typeString: string, typeName: string): boolean {
  // Exact match or match within generics like Result<IntentTree, LinkError>
  const escaped = typeName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return new RegExp(`\\b${escaped}\\b`).test(typeString);
}

// ============================================================
// Task 27: Return Type Verification (Guarantees)
// ============================================================

/**
 * Verify guarantees using TypeScript type checker.
 * Proves return type assertions by inspecting actual function signatures.
 */
export function verifyGuaranteesWithAST(
  file: GlassFile,
  program: ts.Program,
): VerificationAssertion[] {
  const assertions: VerificationAssertion[] = [];
  const checker = program.getTypeChecker();
  const sourceFile = program.getSourceFile(getVirtualPath(file.id));
  if (!sourceFile) return assertions;

  const exportedFunctions = findExportedFunctions(sourceFile);
  const exportedVars = findExportedVariables(sourceFile);
  const exportedTypes = findExportedTypes(sourceFile);

  // Collect all return types from exported functions
  const returnTypes: string[] = [];
  for (const fn of exportedFunctions) {
    const sig = checker.getSignatureFromDeclaration(fn);
    if (sig) {
      const retType = checker.getReturnTypeOfSignature(sig);
      returnTypes.push(checker.typeToString(retType));
    }
  }

  // Collect types of exported variables
  const varTypes: Map<string, string> = new Map();
  for (const v of exportedVars) {
    if (ts.isIdentifier(v.name)) {
      const type = checker.getTypeAtLocation(v);
      varTypes.set(v.name.text, checker.typeToString(type));
    }
  }

  // Verify success guarantees
  for (const guarantee of file.contract.guarantees.onSuccess) {
    const desc = guarantee.description;

    // Pattern: "Returns TypeName" or "result is TypeName"
    const typeMatch = desc.match(/(?:returns?|result\s+is)\s+(\w+)/i);
    if (typeMatch) {
      const expectedType = typeMatch[1];
      const found = returnTypes.some((rt) => typeContains(rt, expectedType));
      if (found) {
        const matchingReturn = returnTypes.find((rt) => typeContains(rt, expectedType));
        assertions.push({
          assertion: desc,
          passed: true,
          level: "PROVEN",
          message: "Return type '" + matchingReturn + "' contains '" + expectedType + "'",
        });
        continue;
      }
    }

    // Pattern: "FunctionName returns/produces TypeName"
    const funcTypeMatch = desc.match(/(\w+)\s+(?:returns?|produces?)\s+(\w+)/i);
    if (funcTypeMatch) {
      const [, funcName, expectedType] = funcTypeMatch;
      const fn = exportedFunctions.find((f) => f.name?.text === funcName);
      if (fn) {
        const sig = checker.getSignatureFromDeclaration(fn);
        if (sig) {
          const retType = checker.typeToString(checker.getReturnTypeOfSignature(sig));
          if (typeContains(retType, expectedType)) {
            assertions.push({
              assertion: desc,
              passed: true,
              level: "PROVEN",
              message: funcName + "() returns " + retType + " (contains " + expectedType + ")",
            });
            continue;
          }
        }
      }
    }

    // Pattern: "ExportName defines/exports/provides X"
    // Check if mentioned identifiers exist as exports
    const exportedNames = [
      ...exportedFunctions.map((f) => f.name?.text).filter(Boolean),
      ...varTypes.keys(),
      ...exportedTypes,
    ];
    const words = desc.match(/\b[A-Z]\w+\b/g) || [];
    const matchedExports = words.filter((w) =>
      exportedNames.some((name) => name === w || name?.toLowerCase() === w.toLowerCase()),
    );

    if (matchedExports.length > 0) {
      assertions.push({
        assertion: desc,
        passed: true,
        level: "PROVEN",
        message: "Exports found: " + matchedExports.join(", "),
      });
      continue;
    }

    // Pattern: identifier mentioned in guarantee exists in implementation
    const identifiers = desc.match(/\b[a-z]\w+(?:\.\w+)*\b/g) || [];
    const foundInImpl = identifiers.some((id) => {
      const parts = id.split(".");
      const name = parts[parts.length - 1];
      return exportedNames.some((n) => n === name) || varTypes.has(name);
    });

    if (foundInImpl) {
      assertions.push({
        assertion: desc,
        passed: true,
        level: "INSTRUMENTED",
        message: "Referenced identifiers found in exports",
      });
      continue;
    }

    // Fallback
    assertions.push({
      assertion: desc,
      passed: true,
      level: "INSTRUMENTED",
      message: "Guarantee requires runtime verification",
    });
  }

  // Verify failure guarantees
  for (const guarantee of file.contract.guarantees.onFailure) {
    const desc = guarantee.description;

    const typeMatch = desc.match(/(?:returns?|result\s+is)\s+(\w+)/i);
    if (typeMatch) {
      const expectedType = typeMatch[1];
      const found = returnTypes.some((rt) => typeContains(rt, expectedType));
      if (found) {
        assertions.push({
          assertion: desc,
          passed: true,
          level: "PROVEN",
          message: "Failure return type contains '" + expectedType + "'",
        });
        continue;
      }
    }

    assertions.push({
      assertion: desc,
      passed: true,
      level: "INSTRUMENTED",
      message: "Failure guarantee requires runtime verification",
    });
  }

  return assertions;
}

// ============================================================
// Task 28: Parameter Type Verification (Requires)
// ============================================================

/**
 * Verify requires using TypeScript type checker.
 * Proves parameter type assertions by inspecting actual function signatures.
 */
export function verifyRequiresWithAST(
  file: GlassFile,
  program: ts.Program,
): VerificationAssertion[] {
  const assertions: VerificationAssertion[] = [];
  const checker = program.getTypeChecker();
  const sourceFile = program.getSourceFile(getVirtualPath(file.id));
  if (!sourceFile) return assertions;

  const exportedFunctions = findExportedFunctions(sourceFile);

  // Collect all parameter info
  const allParams: Array<{ name: string; type: string; funcName: string }> = [];
  for (const fn of exportedFunctions) {
    for (const param of fn.parameters) {
      if (ts.isIdentifier(param.name)) {
        const paramType = checker.getTypeAtLocation(param);
        allParams.push({
          name: param.name.text,
          type: checker.typeToString(paramType),
          funcName: fn.name?.text || "(anonymous)",
        });
      }
    }
  }

  for (const req of file.contract.requires) {
    const desc = req.description;

    // System preconditions stay INSTRUMENTED
    if (desc.toLowerCase().includes("system.") || desc.toLowerCase().includes("system ")) {
      assertions.push({
        assertion: desc,
        passed: true,
        level: "INSTRUMENTED",
        message: "System precondition: runtime verification required",
      });
      continue;
    }

    // Pattern: "paramName is TypeName" or "paramName is an array of TypeName"
    const paramMatch = desc.match(/(\w+)\s+is\s+(?:an?\s+)?(?:array\s+of\s+)?(?:valid\s+)?(\w+)/i);
    if (paramMatch) {
      const [, paramName, expectedType] = paramMatch;
      const matchingParam = allParams.find(
        (p) => p.name === paramName || p.name === paramName.toLowerCase(),
      );

      if (matchingParam && typeContains(matchingParam.type, expectedType)) {
        assertions.push({
          assertion: desc,
          passed: true,
          level: "PROVEN",
          message: "Parameter '" + matchingParam.name + "' has type '" + matchingParam.type +
            "' in " + matchingParam.funcName + "()",
        });
        continue;
      }

      // Check if the expected type appears in any parameter
      const anyMatch = allParams.find((p) => typeContains(p.type, expectedType));
      if (anyMatch) {
        assertions.push({
          assertion: desc,
          passed: true,
          level: "PROVEN",
          message: "Type '" + expectedType + "' found in parameter '" + anyMatch.name +
            "' of " + anyMatch.funcName + "()",
        });
        continue;
      }
    }

    // Pattern: quoted strings like "each file has a unique id" — semantic, can't prove
    if (desc.startsWith('"') || desc.includes("unique") || desc.includes("valid")) {
      assertions.push({
        assertion: desc,
        passed: true,
        level: "INSTRUMENTED",
        message: "Semantic precondition: runtime verification required",
      });
      continue;
    }

    // Check if any identifiers in the description match parameters
    const words = desc.match(/\b[a-z]\w+\b/g) || [];
    const paramFound = words.some((w) => allParams.some((p) => p.name === w));
    if (paramFound) {
      assertions.push({
        assertion: desc,
        passed: true,
        level: "INSTRUMENTED",
        message: "Parameter referenced but type match not confirmable",
      });
      continue;
    }

    // Fallback
    assertions.push({
      assertion: desc,
      passed: true,
      level: "INSTRUMENTED",
      message: "Precondition requires runtime verification",
    });
  }

  return assertions;
}

// ============================================================
// Task 29: Error Handling Verification (Fails)
// ============================================================

/**
 * Verify failure modes using AST traversal.
 * Finds Err() calls, throw statements, and catch blocks to prove error handling.
 */
export function verifyFailureModesWithAST(
  file: GlassFile,
  program: ts.Program,
): VerificationAssertion[] {
  const assertions: VerificationAssertion[] = [];
  const sourceFile = program.getSourceFile(getVirtualPath(file.id));
  if (!sourceFile) return assertions;

  // Find all Err() calls
  const callExpressions = collectNodes(sourceFile, ts.isCallExpression);
  const errCalls = callExpressions.filter((call) => {
    if (ts.isIdentifier(call.expression)) {
      return call.expression.text === "Err";
    }
    return false;
  });

  // Extract error type references from Err() arguments
  const errTypeRefs: string[] = [];
  for (const errCall of errCalls) {
    const argText = errCall.arguments.map((a) => a.getText(sourceFile)).join(" ");
    errTypeRefs.push(argText);
  }

  // Find all throw statements
  const throwStatements = collectNodes(sourceFile, ts.isThrowStatement);
  const throwTexts: string[] = throwStatements.map((t) =>
    t.expression ? t.expression.getText(sourceFile) : "",
  );

  // Find all catch clauses
  const catchClauses = collectNodes(sourceFile, ts.isCatchClause);

  // Find all try statements
  const tryStatements = collectNodes(sourceFile, ts.isTryStatement);
  const hasTryCatch = tryStatements.length > 0;

  for (const failureMode of file.contract.fails) {
    const { errorType } = failureMode;

    // Check Err() calls for the error type
    const errMatch = errTypeRefs.some((text) => {
      const escaped = errorType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      return new RegExp(`\\b${escaped}\\b`).test(text);
    });

    if (errMatch) {
      assertions.push({
        assertion: "Failure mode handled: " + errorType,
        passed: true,
        level: "PROVEN",
        message: "Error '" + errorType + "' found in Err() call via AST",
      });
      continue;
    }

    // Check throw statements
    const throwMatch = throwTexts.some((text) => {
      const escaped = errorType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      return new RegExp(`\\b${escaped}\\b`).test(text);
    });

    if (throwMatch) {
      assertions.push({
        assertion: "Failure mode handled: " + errorType,
        passed: true,
        level: "PROVEN",
        message: "Error '" + errorType + "' found in throw statement via AST",
      });
      continue;
    }

    // Check catch clauses for instanceof or type checks
    let catchMatch = false;
    for (const catchClause of catchClauses) {
      const catchText = catchClause.getText(sourceFile);
      const escaped = errorType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      if (new RegExp(`\\b${escaped}\\b`).test(catchText)) {
        catchMatch = true;
        break;
      }
    }

    if (catchMatch) {
      assertions.push({
        assertion: "Failure mode handled: " + errorType,
        passed: true,
        level: "PROVEN",
        message: "Error '" + errorType + "' handled in catch clause via AST",
      });
      continue;
    }

    // Check if error type appears anywhere in the source text (fallback to pattern matching)
    // Use getFullText() to include leading comments (e.g., @fails JSDoc tags)
    const fullText = sourceFile.getFullText();
    const escaped = errorType.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const referenced = new RegExp(`\\b${escaped}\\b`).test(fullText);

    if (referenced && hasTryCatch) {
      assertions.push({
        assertion: "Failure mode handled: " + errorType,
        passed: true,
        level: "INSTRUMENTED",
        message: "Error '" + errorType + "' referenced; try/catch present",
      });
    } else if (referenced) {
      assertions.push({
        assertion: "Failure mode handled: " + errorType,
        passed: true,
        level: "INSTRUMENTED",
        message: "Error '" + errorType + "' referenced in implementation",
      });
    } else {
      assertions.push({
        assertion: "Failure mode handled: " + errorType,
        passed: false,
        level: "TESTED",
        message: "Error '" + errorType + "' not found in AST",
      });
    }
  }

  return assertions;
}

// ============================================================
// Task 30: Invariant Verification
// ============================================================

/**
 * Verify invariants using AST-based data flow analysis.
 * Detects mutation patterns and sensitive data exposure.
 */
export function verifyInvariantsWithAST(
  file: GlassFile,
  program: ts.Program,
): VerificationAssertion[] {
  const assertions: VerificationAssertion[] = [];
  const checker = program.getTypeChecker();
  const sourceFile = program.getSourceFile(getVirtualPath(file.id));
  if (!sourceFile) return assertions;

  const exportedFunctions = findExportedFunctions(sourceFile);

  for (const invariant of file.contract.invariants) {
    const desc = invariant.description;

    // Pattern: "never modified" / "never mutated" / "are never modified"
    if (/never\s+modif/i.test(desc)) {
      const paramMatch = desc.match(/(\w+)\s+(?:is|are)\s+never\s+modif/i) ||
                          desc.match(/(\w+)\s+never\s+modif/i);
      if (paramMatch) {
        const targetName = paramMatch[1].toLowerCase();

        // Find matching parameters across exported functions
        let mutated = false;
        for (const fn of exportedFunctions) {
          for (const param of fn.parameters) {
            if (!ts.isIdentifier(param.name)) continue;
            if (param.name.text.toLowerCase() !== targetName) continue;

            // Check for mutation patterns in the function body
            if (fn.body) {
              const assignments = collectNodes(fn.body, ts.isBinaryExpression);
              for (const assign of assignments) {
                if (
                  assign.operatorToken.kind === ts.SyntaxKind.EqualsToken &&
                  assign.left.getText(sourceFile).startsWith(param.name.text)
                ) {
                  mutated = true;
                }
              }

              // Check for method calls that mutate (.push, .pop, .splice, .sort, .reverse)
              const calls = collectNodes(fn.body, ts.isCallExpression);
              for (const call of calls) {
                if (ts.isPropertyAccessExpression(call.expression)) {
                  const obj = call.expression.expression;
                  const method = call.expression.name.text;
                  if (
                    obj.getText(sourceFile) === param.name.text &&
                    ["push", "pop", "splice", "sort", "reverse", "shift", "unshift", "fill"].includes(method)
                  ) {
                    mutated = true;
                  }
                }
              }
            }
          }
        }

        assertions.push({
          assertion: desc,
          passed: !mutated,
          level: "PROVEN",
          message: mutated
            ? "VIOLATION: '" + targetName + "' is mutated in implementation"
            : "'" + targetName + "' is not mutated (no assignment/mutation patterns found)",
        });
        continue;
      }
    }

    // Pattern: "never exposed" — check for logging/returning sensitive data
    if (/never\s+exposed/i.test(desc)) {
      const fieldMatch = desc.match(/(\w+(?:\.\w+)*)\s+(?:is\s+)?never\s+exposed/i);
      if (fieldMatch) {
        const fieldName = fieldMatch[1].split(".").pop()!;
        let exposed = false;

        // Check console.log/error/warn calls
        const calls = collectNodes(sourceFile, ts.isCallExpression);
        for (const call of calls) {
          if (ts.isPropertyAccessExpression(call.expression)) {
            const obj = call.expression.expression;
            const method = call.expression.name.text;
            if (
              ts.isIdentifier(obj) && obj.text === "console" &&
              ["log", "error", "warn", "info", "debug"].includes(method)
            ) {
              const argTexts = call.arguments.map((a) => a.getText(sourceFile));
              if (argTexts.some((t) => new RegExp(`\\b${fieldName}\\b`).test(t))) {
                exposed = true;
              }
            }
          }
        }

        assertions.push({
          assertion: desc,
          passed: !exposed,
          level: "PROVEN",
          message: exposed
            ? "VIOLATION: '" + fieldName + "' may be exposed via console output"
            : "'" + fieldName + "' not found in logging/output calls",
        });
        continue;
      }
    }

    // Pattern: "deterministic" — can verify no Math.random, Date.now, etc.
    if (/deterministic/i.test(desc)) {
      const calls = collectNodes(sourceFile, ts.isCallExpression);
      let nonDeterministic = false;
      for (const call of calls) {
        const text = call.expression.getText(sourceFile);
        if (
          text === "Math.random" ||
          text === "Date.now" ||
          text === "crypto.randomUUID" ||
          text === "crypto.getRandomValues"
        ) {
          nonDeterministic = true;
        }
      }

      // Check for Date construction (new Date() without args)
      const newExprs = collectNodes(sourceFile, ts.isNewExpression);
      for (const ne of newExprs) {
        if (ne.expression.getText(sourceFile) === "Date" && (!ne.arguments || ne.arguments.length === 0)) {
          nonDeterministic = true;
        }
      }

      assertions.push({
        assertion: desc,
        passed: !nonDeterministic,
        level: nonDeterministic ? "INSTRUMENTED" : "PROVEN",
        message: nonDeterministic
          ? "Non-deterministic call found (Date.now/Math.random/etc.)"
          : "No non-deterministic calls detected",
      });
      continue;
    }

    // Pattern: "stateless" — verify no module-level mutable state
    if (/stateless/i.test(desc)) {
      let hasMutableState = false;
      ts.forEachChild(sourceFile, (node) => {
        if (ts.isVariableStatement(node)) {
          for (const decl of node.declarationList.declarations) {
            if (!(node.declarationList.flags & ts.NodeFlags.Const)) {
              hasMutableState = true;
            }
          }
        }
      });

      assertions.push({
        assertion: desc,
        passed: !hasMutableState,
        level: "PROVEN",
        message: hasMutableState
          ? "Module-level mutable variables found (let/var)"
          : "No module-level mutable state detected",
      });
      continue;
    }

    // Pattern: "pure re-export" — verify only import/export statements
    if (/pure\s+re-export/i.test(desc)) {
      let hasLogic = false;
      ts.forEachChild(sourceFile, (node) => {
        // Skip EOF token and type-only nodes
        if (node.kind === ts.SyntaxKind.EndOfFileToken) return;
        if (ts.isInterfaceDeclaration(node) || ts.isTypeAliasDeclaration(node)) return;

        if (
          !ts.isImportDeclaration(node) &&
          !ts.isExportDeclaration(node) &&
          !ts.isExportAssignment(node) &&
          !(ts.isVariableStatement(node) && node.declarationList.declarations.every((d) =>
            d.initializer && ts.isStringLiteral(d.initializer)
          ))
        ) {
          // Allow exported variable statements (const exports)
          if (!ts.isVariableStatement(node) || !node.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword)) {
            hasLogic = true;
          }
        }
      });

      assertions.push({
        assertion: desc,
        passed: !hasLogic,
        level: hasLogic ? "INSTRUMENTED" : "PROVEN",
        message: hasLogic
          ? "Module contains logic beyond re-exports"
          : "Module is pure re-exports",
      });
      continue;
    }

    // Generic invariant — fallback
    assertions.push({
      assertion: desc,
      passed: true,
      level: "INSTRUMENTED",
      message: "Invariant requires runtime verification",
    });
  }

  return assertions;
}
