=== Glass Unit ===
id: compiler.parser
version: 0.1.0
language: typescript

=== Intent ===
purpose: Parse .glass files into structured GlassFile objects, extracting the three layers (Intent, Contract, Implementation)
source:
  kind: prd
  reference: "PRD Section 4 and 11.1 step 1"
parent: glass.compiler
stakeholder: engineering
subIntents: []
approvalStatus: approved

=== Contract ===
requires:
  - "filePath is a valid string path"
  - "file exists on disk for parseGlassFile"
  - "content follows .glass format with four sections"
guarantees:
  on_success:
    - "Returns GlassFile with all three sections extracted"
    - "id, version, and language are populated from Glass Unit header"
    - "Intent has purpose, source, parent, stakeholder, subIntents"
    - "Contract has requires, guarantees, invariants, fails, advisories"
  on_failure:
    - "Returns ParseError with reason, message, and filePath"
    - "ParseError includes section where failure occurred"
invariants:
  - "Original file is never modified"
  - "Parser is stateless"
fails:
  FileNotFound: "Error(ParseError, reason: FileNotFound)"
  InvalidFormat: "Error(ParseError, reason: InvalidFormat)"
  MissingSection: "Error(ParseError, reason: MissingSection)"
  InvalidSectionContent: "Error(ParseError, reason: InvalidSectionContent)"
advisories:

=== Implementation ===
/**
 * Glass File Parser — reads .glass files and extracts intent, contract,
 * and implementation sections into typed GlassFile objects.
 *
 * This is the first stage of the Glass compiler pipeline.
 * Implements all subtasks from Task 4:
 *   4.1 — Result type (in types/index.ts)
 *   4.2 — Section splitter with line tracking
 *   4.3 — Intent section parser + Glass Unit header parser
 *   4.4 — Contract section parser
 *   4.5 — GlassParser orchestrator with file I/O and validation
 */

import * as fs from "fs";
import type {
  GlassFile,
  Intent,
  IntentSource,
  Contract,
  ContractAssertion,
  FailureMode,
  Advisory,
  Stakeholder,
  ApprovalStatus,
  SubIntentRef,
  TargetLanguage,
  ParseError,
  Result,
} from "../types/index";
import { Ok, Err } from "../types/index";

// ============================================================
// Section Splitter (Subtask 4.2)
// ============================================================

/** Section markers in the .glass file format. */
const SECTION_MARKERS = [
  "=== Glass Unit ===",
  "=== Intent ===",
  "=== Contract ===",
  "=== Implementation ===",
] as const;

type SectionName = "Glass Unit" | "Intent" | "Contract" | "Implementation";

/** Raw sections extracted from a .glass file before parsing. */
interface RawSections {
  glassUnit: { content: string; startLine: number };
  intent: { content: string; startLine: number };
  contract: { content: string; startLine: number };
  implementation: { content: string; startLine: number };
}

/**
 * Split raw .glass file content by section markers.
 * Tracks line numbers for each section start.
 */
function splitSections(content: string, filePath: string): Result<RawSections, ParseError> {
  const lines = content.split(/\r?\n/);
  const sectionStarts: { marker: string; line: number; index: number }[] = [];

  for (let i = 0; i < lines.length; i++) {
    const trimmed = lines[i].trim();
    if (SECTION_MARKERS.includes(trimmed as typeof SECTION_MARKERS[number])) {
      sectionStarts.push({ marker: trimmed, line: i + 1, index: sectionStarts.length });
    }
  }

  // Validate all four sections present
  for (const expected of SECTION_MARKERS) {
    if (!sectionStarts.find((s) => s.marker === expected)) {
      const sectionName = expected.replace(/^=== | ===$/g, "") as SectionName;
      return Err({
        reason: "MissingSection",
        message: "Missing required section: " + expected,
        filePath,
        section: sectionName,
      });
    }
  }

  // Validate section order
  const expectedOrder = [...SECTION_MARKERS];
  for (let i = 0; i < sectionStarts.length; i++) {
    if (sectionStarts[i].marker !== expectedOrder[i]) {
      return Err({
        reason: "InvalidFormat",
        message: "Sections are out of order. Expected: " + expectedOrder[i] +
          " but found: " + sectionStarts[i].marker + " at line " + sectionStarts[i].line,
        filePath,
        line: sectionStarts[i].line,
      });
    }
  }

  // Extract content between markers
  const getContent = (markerIdx: number): { content: string; startLine: number } => {
    const startLine = sectionStarts[markerIdx].line; // 1-based line of marker
    const contentStartLine = startLine + 1; // Line after marker
    const contentStartIdx = startLine; // 0-based index into lines array (line after marker)
    const endIdx = markerIdx + 1 < sectionStarts.length
      ? sectionStarts[markerIdx + 1].line - 1 // 0-based index of next marker
      : lines.length;
    return {
      content: lines.slice(contentStartIdx, endIdx).join("\n").trim(),
      startLine: contentStartLine,
    };
  };

  return Ok({
    glassUnit: getContent(0),
    intent: getContent(1),
    contract: getContent(2),
    implementation: getContent(3),
  });
}

// ============================================================
// Glass Unit Header Parser (Subtask 4.3)
// ============================================================

interface GlassUnitHeader {
  id: string;
  version: string;
  language: TargetLanguage;
}

/**
 * Parse the Glass Unit header section.
 * Extracts id, version, and language.
 */
function parseGlassUnitHeader(
  content: string,
  startLine: number,
  filePath: string,
): Result<GlassUnitHeader, ParseError> {
  const kvPairs = parseKeyValuePairs(content);

  const id = kvPairs.get("id");
  if (!id) {
    return Err({
      reason: "InvalidSectionContent",
      message: "Glass Unit header missing required field: id",
      filePath,
      line: startLine,
      section: "Glass Unit",
    });
  }

  const version = kvPairs.get("version");
  if (!version) {
    return Err({
      reason: "InvalidSectionContent",
      message: "Glass Unit header missing required field: version",
      filePath,
      line: startLine,
      section: "Glass Unit",
    });
  }

  const language = kvPairs.get("language");
  if (!language || (language !== "typescript" && language !== "rust")) {
    return Err({
      reason: "InvalidSectionContent",
      message: "Glass Unit header has invalid or missing language (expected 'typescript' or 'rust')",
      filePath,
      line: startLine,
      section: "Glass Unit",
    });
  }

  return Ok({ id, version, language });
}

// ============================================================
// Intent Section Parser (Subtask 4.3)
// ============================================================

/**
 * Parse the Intent section into a typed Intent object.
 */
function parseIntentSection(
  content: string,
  startLine: number,
  filePath: string,
): Result<Intent, ParseError> {
  const kvPairs = parseKeyValuePairs(content);

  const purpose = kvPairs.get("purpose");
  if (!purpose) {
    return Err({
      reason: "InvalidSectionContent",
      message: "Intent section missing required field: purpose",
      filePath,
      line: startLine,
      section: "Intent",
    });
  }

  const sourceStr = kvPairs.get("source") || "ai-generated";
  const source = parseIntentSource(sourceStr);

  const parentStr = kvPairs.get("parent");
  const parent = (!parentStr || parentStr === "null") ? null : parentStr;

  const stakeholderStr = kvPairs.get("stakeholder") || "engineering";
  const stakeholder = parseStakeholder(stakeholderStr);

  const subIntents = parseSubIntents(content);

  return Ok({
    purpose,
    source,
    parent,
    stakeholder,
    subIntents,
    approvalStatus: "approved" as ApprovalStatus,
  });
}

/**
 * Parse intent source string into IntentSource.
 */
function parseIntentSource(sourceStr: string): IntentSource {
  if (sourceStr.startsWith("conversation/") || sourceStr.startsWith("conversation:")) {
    const sessionId = sourceStr.replace(/^conversation[/:]/, "");
    return { kind: "conversation", sessionId };
  }
  if (sourceStr === "ai-generated" || sourceStr.startsWith("ai-generated")) {
    const reason = sourceStr.includes(",")
      ? sourceStr.split(",").slice(1).join(",").trim()
      : "auto";
    return { kind: "ai-generated", reason };
  }
  // Default: treat as PRD reference
  return { kind: "prd", reference: sourceStr };
}

/**
 * Parse stakeholder string.
 */
function parseStakeholder(str: string): Stakeholder {
  const normalized = str.trim().toLowerCase();
  if (normalized === "user" || normalized === "product" ||
      normalized === "engineering" || normalized === "security") {
    return normalized;
  }
  return "engineering";
}

/**
 * Parse sub-intents list from intent content.
 * Looks for lines starting with "  - " under "sub-intents:".
 */
function parseSubIntents(content: string): SubIntentRef[] {
  const subIntents: SubIntentRef[] = [];
  const lines = content.split("\n");
  let inSubIntents = false;

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed === "sub-intents:" || trimmed === "sub_intents:") {
      inSubIntents = true;
      continue;
    }

    if (inSubIntents) {
      if (trimmed.startsWith("- ")) {
        const value = trimmed.slice(2).trim();
        const match = value.match(/^([^\s(]+)\s*(?:\(([^)]+)\))?$/);
        if (match) {
          const id = match[1];
          const annotations = match[2]
            ? match[2].split(",").map((a) => a.trim())
            : undefined;
          subIntents.push({ id, annotations });
        } else {
          subIntents.push({ id: value });
        }
      } else if (trimmed && !trimmed.startsWith("- ")) {
        // End of sub-intents list (hit a non-list-item, non-empty line)
        inSubIntents = false;
      }
    }
  }

  return subIntents;
}

// ============================================================
// Contract Section Parser (Subtask 4.4)
// ============================================================

/**
 * Parse the Contract section into a typed Contract object.
 */
function parseContractSection(
  content: string,
  startLine: number,
  filePath: string,
): Result<Contract, ParseError> {
  const subsections = parseContractSubsections(content);

  const requires = parseAssertionList(subsections.get("requires") || "");
  const onSuccess = parseAssertionList(subsections.get("on_success") || subsections.get("on success") || "");
  const onFailure = parseAssertionList(subsections.get("on_failure") || subsections.get("on failure") || "");
  const invariants = parseAssertionList(subsections.get("invariants") || "");
  const fails = parseFailureModes(subsections.get("fails") || "");
  const advisories = parseAdvisories(subsections.get("advisories") || "");

  // Also handle guarantees as a parent of on_success / on_failure
  if (onSuccess.length === 0 && onFailure.length === 0) {
    const guaranteesContent = subsections.get("guarantees") || "";
    if (guaranteesContent) {
      // If guarantees section exists but no on_success/on_failure subsections,
      // treat the whole thing as success guarantees
      const guaranteeAssertions = parseAssertionList(guaranteesContent);
      return Ok({
        requires,
        guarantees: { onSuccess: guaranteeAssertions, onFailure: [] },
        invariants,
        fails,
        advisories,
      });
    }
  }

  return Ok({
    requires,
    guarantees: { onSuccess, onFailure },
    invariants,
    fails,
    advisories,
  });
}

/**
 * Split contract content into named subsections.
 * Subsections are detected by lines ending with ":" that match known names.
 */
function parseContractSubsections(content: string): Map<string, string> {
  const subsections = new Map<string, string>();
  const lines = content.split("\n");
  let currentSubsection: string | null = null;
  let currentLines: string[] = [];

  const knownSubsections = new Set([
    "requires", "guarantees", "on_success", "on_failure",
    "invariants", "fails", "advisories",
  ]);

  for (const line of lines) {
    const trimmed = line.trim();
    const labelMatch = trimmed.match(/^(\w[\w\s]*?):\s*$/);

    if (labelMatch) {
      const label = labelMatch[1].toLowerCase().replace(/\s+/g, "_");
      if (knownSubsections.has(label)) {
        // Save previous subsection
        if (currentSubsection !== null) {
          subsections.set(currentSubsection, currentLines.join("\n").trim());
        }
        currentSubsection = label;
        currentLines = [];
        continue;
      }
    }

    if (currentSubsection !== null) {
      currentLines.push(line);
    }
  }

  // Save last subsection
  if (currentSubsection !== null) {
    subsections.set(currentSubsection, currentLines.join("\n").trim());
  }

  return subsections;
}

/**
 * Parse a list of "- assertion text" lines into ContractAssertions.
 */
function parseAssertionList(content: string): ContractAssertion[] {
  const assertions: ContractAssertion[] = [];
  const lines = content.split("\n");
  let currentAssertion: string | null = null;

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith("- ")) {
      // Save previous multi-line assertion
      if (currentAssertion !== null) {
        assertions.push({ description: currentAssertion });
      }
      currentAssertion = trimmed.slice(2).trim();
    } else if (currentAssertion !== null && trimmed) {
      // Continuation line (deeper indentation)
      currentAssertion += " " + trimmed;
    }
  }

  // Save last assertion
  if (currentAssertion !== null) {
    assertions.push({ description: currentAssertion });
  }

  return assertions;
}

/**
 * Parse failure modes from "ErrorType: handling" format.
 */
function parseFailureModes(content: string): FailureMode[] {
  const modes: FailureMode[] = [];
  const lines = content.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) continue;

    // Match "ErrorType: handling strategy"
    const colonIdx = trimmed.indexOf(":");
    if (colonIdx > 0) {
      const errorType = trimmed.slice(0, colonIdx).trim();
      const handling = trimmed.slice(colonIdx + 1).trim();
      if (errorType && handling) {
        modes.push({ errorType, handling });
      }
    }
  }

  return modes;
}

/**
 * Parse advisories from "- advisory text" format.
 */
function parseAdvisories(content: string): Advisory[] {
  const advisories: Advisory[] = [];
  const lines = content.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.startsWith("- ")) {
      advisories.push({
        description: trimmed.slice(2).trim(),
        resolved: false,
      });
    }
  }

  return advisories;
}

// ============================================================
// Utility: Key-Value Parser
// ============================================================

/**
 * Parse YAML-like "key: value" pairs from content.
 * Splits on first colon only (values may contain colons).
 */
function parseKeyValuePairs(content: string): Map<string, string> {
  const pairs = new Map<string, string>();
  const lines = content.split("\n");

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#") || trimmed.startsWith("-")) continue;

    const colonIdx = trimmed.indexOf(":");
    if (colonIdx > 0) {
      const key = trimmed.slice(0, colonIdx).trim().toLowerCase().replace(/-/g, "_");
      const value = trimmed.slice(colonIdx + 1).trim();
      // Skip subsection headers (value is empty, and next lines are list items)
      if (value) {
        pairs.set(key, value);
      }
    }
  }

  return pairs;
}

// ============================================================
// GlassParser Orchestrator (Subtask 4.5)
// ============================================================

/**
 * Parse a .glass file from a file path.
 */
export function parseGlassFile(filePath: string): Result<GlassFile, ParseError> {
  let content: string;
  try {
    content = fs.readFileSync(filePath, "utf-8");
  } catch {
    return Err({
      reason: "FileNotFound",
      message: "File not found or not readable: " + filePath,
      filePath,
    });
  }

  return parseGlassContent(content, filePath);
}

/**
 * Parse .glass content from a string.
 */
export function parseGlassContent(
  content: string,
  filePath: string,
): Result<GlassFile, ParseError> {
  // Step 1: Split into sections
  const sections = splitSections(content, filePath);
  if (!sections.ok) {
    return sections;
  }

  const raw = sections.value;

  // Step 2: Parse Glass Unit header
  const header = parseGlassUnitHeader(raw.glassUnit.content, raw.glassUnit.startLine, filePath);
  if (!header.ok) {
    return header;
  }

  // Step 3: Parse Intent section
  const intent = parseIntentSection(raw.intent.content, raw.intent.startLine, filePath);
  if (!intent.ok) {
    return intent;
  }

  // Step 4: Parse Contract section
  const contract = parseContractSection(raw.contract.content, raw.contract.startLine, filePath);
  if (!contract.ok) {
    return contract;
  }

  // Step 5: Extract implementation as-is
  const implementation = raw.implementation.content;

  // Step 6: Assemble GlassFile
  return Ok({
    id: header.value.id,
    version: header.value.version,
    language: header.value.language,
    intent: intent.value,
    contract: contract.value,
    implementation,
  });
}

