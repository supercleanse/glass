=== Glass Unit ===
id: compiler.emitter
version: 0.1.0
language: typescript

=== Intent ===
purpose: Output clean standard TypeScript from verified .glass files with dependency resolution and atomic writes
source:
  kind: prd
  reference: "PRD Section 11.1 step 6"
parent: glass.compiler
stakeholder: engineering
subIntents: []
approvalStatus: approved

=== Contract ===
requires:
  - "files are verified GlassFile objects (all contracts satisfied)"
  - "verificationResults contains PROVEN status for each file"
  - "outputDir is a valid writable path"
guarantees:
  on_success:
    - "Emitted TypeScript compiles with tsc"
    - "No Glass artifacts in output code"
    - "Each file has auto-generated header comment"
    - "tsconfig.json generated for the output"
  on_failure:
    - "Returns EmitterError with reason and details"
    - "No partial files written on failure"
invariants:
  - "Source .glass files are never modified"
  - "Emission is deterministic"
fails:
  VerificationNotPassed: "Error(EmitterError, reason: VerificationNotPassed)"
  WriteError: "Error(EmitterError, reason: WriteError)"
advisories:

=== Implementation ===
/**
 * Glass TypeScript Emitter — outputs clean, standard TypeScript code
 * from verified .glass files.
 *
 * This is the fourth and final stage of the Glass compiler pipeline.
 * Implements: dependency resolution, file emission with import rewriting,
 * instrumentation injection, tsconfig.json and package.json generation,
 * verification gate, and atomic output.
 */

import * as fs from "fs";
import * as path from "path";
import type {
  GlassFile,
  VerificationResult,
  EmitterError,
  EmitterErrorReason,
  Result,
  CompilerOptions,
  DiagnosticMessage,
} from "../types/index";
import { Ok, Err } from "../types/index";
import type { InstrumentationPlan } from "./verifier";

// ============================================================
// Types
// ============================================================

/** Result of emitting code for a project. */
export interface EmitResult {
  success: boolean;
  outputFiles: string[];
  diagnostics: DiagnosticMessage[];
}

/** Options for the TypeScript emitter. */
export interface EmitterOptions {
  files: GlassFile[];
  outputDir: string;
  verificationResults: Map<string, VerificationResult>;
  instrumentationPlans?: Map<string, InstrumentationPlan>;
  projectName?: string;
  projectVersion?: string;
  sourceMapEnabled?: boolean;
  cleanOutput?: boolean;
}

/** A resolved module dependency between two Glass units. */
export interface ModuleDependency {
  sourceId: string;
  targetId: string;
  importStatement: string;
  rewrittenImport: string;
}

/** The resolved dependency graph for all Glass units. */
export interface DependencyGraph {
  nodes: Map<string, GlassFile>;
  edges: ModuleDependency[];
  emissionOrder: string[];
  externalDependencies: Set<string>;
}

// ============================================================
// Dependency Resolution
// ============================================================

/** Known npm package prefixes to detect external imports. */
const BUILTIN_MODULES = new Set([
  "fs", "path", "os", "child_process", "crypto", "http", "https",
  "net", "url", "util", "stream", "events", "buffer", "querystring",
  "assert", "zlib", "readline", "tls", "dns", "cluster", "worker_threads",
]);

/**
 * Extract import statements from implementation code.
 * Returns array of { raw, modulePath, isRelative, isExternal }.
 */
function extractImports(implementation: string): {
  raw: string;
  modulePath: string;
  isRelative: boolean;
  isBuiltin: boolean;
}[] {
  const imports: ReturnType<typeof extractImports> = [];

  // Match ES module imports: import ... from "..."
  const esImportRegex = /import\s+(?:(?:type\s+)?(?:\{[^}]*\}|[\w*]+(?:\s*,\s*\{[^}]*\})?)\s+from\s+)?['"]([^'"]+)['"]/g;
  let match: RegExpExecArray | null;
  while ((match = esImportRegex.exec(implementation)) !== null) {
    const modulePath = match[1];
    imports.push({
      raw: match[0],
      modulePath,
      isRelative: modulePath.startsWith(".") || modulePath.startsWith("/"),
      isBuiltin: BUILTIN_MODULES.has(modulePath.split("/")[0]),
    });
  }

  // Match require() calls
  const requireRegex = /require\s*\(\s*['"]([^'"]+)['"]\s*\)/g;
  while ((match = requireRegex.exec(implementation)) !== null) {
    const modulePath = match[1];
    imports.push({
      raw: match[0],
      modulePath,
      isRelative: modulePath.startsWith(".") || modulePath.startsWith("/"),
      isBuiltin: BUILTIN_MODULES.has(modulePath.split("/")[0]),
    });
  }

  return imports;
}

/**
 * Resolve dependencies between Glass files and compute emission order.
 */
function resolveDependencies(files: GlassFile[]): Result<DependencyGraph, EmitterError> {
  const nodes = new Map<string, GlassFile>();
  const edges: ModuleDependency[] = [];
  const externalDependencies = new Set<string>();

  for (const file of files) {
    nodes.set(file.id, file);
  }

  // Build adjacency for topological sort
  const adjacency = new Map<string, string[]>();
  const inDegree = new Map<string, number>();
  for (const file of files) {
    adjacency.set(file.id, []);
    inDegree.set(file.id, 0);
  }

  for (const file of files) {
    const imports = extractImports(file.implementation);
    for (const imp of imports) {
      if (imp.isRelative) {
        // Try to map relative import to a Glass unit ID
        // For now, relative imports are passed through
      } else if (!imp.isBuiltin) {
        // External npm dependency
        const pkgName = imp.modulePath.startsWith("@")
          ? imp.modulePath.split("/").slice(0, 2).join("/")
          : imp.modulePath.split("/")[0];
        externalDependencies.add(pkgName);
      }
    }

    // Check sub-intent references as implicit dependencies
    for (const subIntent of file.intent.subIntents) {
      if (nodes.has(subIntent.id)) {
        edges.push({
          sourceId: file.id,
          targetId: subIntent.id,
          importStatement: "",
          rewrittenImport: "",
        });
        adjacency.get(file.id)!.push(subIntent.id);
        inDegree.set(subIntent.id, (inDegree.get(subIntent.id) || 0) + 1);
      }
    }
  }

  // Topological sort (Kahn's algorithm)
  const queue: string[] = [];
  for (const [id, degree] of inDegree) {
    if (degree === 0) queue.push(id);
  }

  const emissionOrder: string[] = [];
  while (queue.length > 0) {
    const current = queue.shift()!;
    emissionOrder.push(current);
    for (const neighbor of adjacency.get(current) || []) {
      const newDegree = (inDegree.get(neighbor) || 1) - 1;
      inDegree.set(neighbor, newDegree);
      if (newDegree === 0) queue.push(neighbor);
    }
  }

  // If not all nodes are in emission order, there's a cycle
  if (emissionOrder.length < files.length) {
    // Add remaining nodes in original order (cycle should have been caught by linker)
    for (const file of files) {
      if (!emissionOrder.includes(file.id)) {
        emissionOrder.push(file.id);
      }
    }
  }

  return Ok({ nodes, edges, emissionOrder, externalDependencies });
}

// ============================================================
// File Emission
// ============================================================

/**
 * Convert a Glass unit ID to an output file path.
 * e.g. "auth.authenticate_user" -> "dist/auth/authenticate_user.ts"
 */
export function mapGlassIdToPath(id: string, outputDir: string): string {
  const parts = id.split(".");
  const fileName = parts.pop() + ".ts";
  const dirParts = parts;
  return path.join(outputDir, ...dirParts, fileName);
}

/**
 * Generate the auto-generated header comment.
 */
function generateHeader(file: GlassFile): string {
  return `// Generated by Glass Compiler v${file.version} from ${file.id}\n// Do not edit directly — modify the source .glass file instead.\n`;
}

/**
 * Inject instrumentation checks into the implementation code.
 */
function injectInstrumentation(code: string, plan: InstrumentationPlan): string {
  if (plan.checks.length === 0) return code;

  const preChecks = plan.checks.filter((c) => c.insertionPoint === "pre");
  const postChecks = plan.checks.filter((c) => c.insertionPoint === "post");
  const invariantChecks = plan.checks.filter((c) => c.insertionPoint === "invariant");

  let result = code;

  // Inject precondition checks at function entry (after first opening brace)
  if (preChecks.length > 0) {
    const preCode = preChecks.map((c) => "  " + c.checkCode).join("\n");
    const firstBrace = result.indexOf("{");
    if (firstBrace !== -1) {
      result = result.slice(0, firstBrace + 1) + "\n" + preCode + result.slice(firstBrace + 1);
    }
  }

  // Add invariant checks as comments (full injection deferred to Phase 2)
  if (invariantChecks.length > 0) {
    const invariantCode = invariantChecks.map((c) => "  " + c.checkCode).join("\n");
    result = result + "\n" + invariantCode;
  }

  return result;
}

/**
 * Emit a single GlassFile to a TypeScript file.
 */
function emitFile(
  file: GlassFile,
  outputDir: string,
  instrumentationPlan?: InstrumentationPlan,
): Result<string, EmitterError> {
  const outputPath = mapGlassIdToPath(file.id, outputDir);
  const dir = path.dirname(outputPath);

  // Ensure directory exists
  try {
    fs.mkdirSync(dir, { recursive: true });
  } catch (err) {
    return Err({
      reason: "WriteError",
      message: "Failed to create output directory: " + dir,
      unitId: file.id,
      details: [String(err)],
    });
  }

  // Build file content
  let content = generateHeader(file) + "\n";

  // Add implementation
  let implementation = file.implementation;

  // Inject instrumentation if available
  if (instrumentationPlan && instrumentationPlan.checks.length > 0) {
    // Add GlassContractViolation class import
    content += `class GlassContractViolation extends Error {\n  constructor(public assertion: string) {\n    super("Glass contract violation: " + assertion);\n    this.name = "GlassContractViolation";\n  }\n}\n\n`;
    implementation = injectInstrumentation(implementation, instrumentationPlan);
  }

  content += implementation + "\n";

  // Write file atomically (write to temp, then rename)
  const tmpPath = outputPath + ".glass-tmp";
  try {
    fs.writeFileSync(tmpPath, content, "utf-8");
    fs.renameSync(tmpPath, outputPath);
  } catch (err) {
    // Clean up temp file if rename failed
    try { fs.unlinkSync(tmpPath); } catch { /* ignore */ }
    return Err({
      reason: "WriteError",
      message: "Failed to write output file: " + outputPath,
      unitId: file.id,
      details: [String(err)],
    });
  }

  return Ok(outputPath);
}

// ============================================================
// tsconfig.json Generator
// ============================================================

/**
 * Generate a tsconfig.json for the output directory.
 */
function generateTsConfig(outputDir: string, moduleSystem: "commonjs" | "esnext" = "commonjs"): Result<void, EmitterError> {
  const config = {
    compilerOptions: {
      target: "ES2020",
      module: moduleSystem === "esnext" ? "ESNext" : "Node16",
      moduleResolution: moduleSystem === "esnext" ? "bundler" : "Node16",
      strict: true,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      outDir: "./compiled",
      declaration: true,
      declarationMap: true,
      sourceMap: true,
      resolveJsonModule: true,
    },
    include: ["**/*.ts"],
    exclude: ["node_modules", "compiled"],
  };

  const configPath = path.join(outputDir, "tsconfig.json");
  const tmpPath = configPath + ".glass-tmp";

  try {
    fs.writeFileSync(tmpPath, JSON.stringify(config, null, 2) + "\n", "utf-8");
    fs.renameSync(tmpPath, configPath);
  } catch (err) {
    try { fs.unlinkSync(tmpPath); } catch { /* ignore */ }
    return Err({
      reason: "WriteError",
      message: "Failed to write tsconfig.json",
      details: [String(err)],
    });
  }

  return Ok(undefined);
}

// ============================================================
// package.json Generator
// ============================================================

/**
 * Generate a package.json for the output directory.
 */
function generatePackageJson(
  outputDir: string,
  options: {
    projectName: string;
    version: string;
    entryPoint?: string;
    externalDependencies: Set<string>;
  },
): Result<void, EmitterError> {
  const name = options.projectName
    .toLowerCase()
    .replace(/[^a-z0-9@/._-]/g, "-");

  const dependencies: Record<string, string> = {};
  for (const dep of options.externalDependencies) {
    dependencies[dep] = "*";
  }

  const pkg = {
    name,
    version: options.version,
    main: options.entryPoint || "index.ts",
    scripts: {
      build: "tsc",
    },
    dependencies,
    devDependencies: {
      typescript: "^5.0.0",
      "@types/node": "^20.0.0",
    },
  };

  const pkgPath = path.join(outputDir, "package.json");
  const tmpPath = pkgPath + ".glass-tmp";

  try {
    fs.writeFileSync(tmpPath, JSON.stringify(pkg, null, 2) + "\n", "utf-8");
    fs.renameSync(tmpPath, pkgPath);
  } catch (err) {
    try { fs.unlinkSync(tmpPath); } catch { /* ignore */ }
    return Err({
      reason: "WriteError",
      message: "Failed to write package.json",
      details: [String(err)],
    });
  }

  return Ok(undefined);
}

// ============================================================
// Emitter Orchestrator
// ============================================================

/**
 * Emit TypeScript code from verified GlassFiles.
 * Refuses to emit if any verification has failed.
 */
export function emitTypeScript(
  files: GlassFile[],
  verificationResults: Map<string, VerificationResult>,
  outputDir: string,
  options?: {
    instrumentationPlans?: Map<string, InstrumentationPlan>;
    projectName?: string;
    projectVersion?: string;
    cleanOutput?: boolean;
  },
): Result<string[], EmitterError> {
  // Step 1: Verification gate — refuse to emit unverified code
  for (const file of files) {
    const result = verificationResults.get(file.id);
    if (!result) {
      return Err({
        reason: "VerificationNotPassed",
        message: "No verification result for unit: " + file.id,
        unitId: file.id,
      });
    }
    if (result.status === "FAILED") {
      return Err({
        reason: "VerificationNotPassed",
        message: "Verification failed for unit: " + file.id,
        unitId: file.id,
      });
    }
  }

  // Step 2: Resolve dependencies
  const graphResult = resolveDependencies(files);
  if (!graphResult.ok) return graphResult;
  const graph = graphResult.value;

  // Step 3: Clean output if requested
  if (options?.cleanOutput && fs.existsSync(outputDir)) {
    try {
      fs.rmSync(outputDir, { recursive: true, force: true });
    } catch (err) {
      return Err({
        reason: "WriteError",
        message: "Failed to clean output directory: " + outputDir,
        details: [String(err)],
      });
    }
  }

  // Step 4: Create output directory
  try {
    fs.mkdirSync(outputDir, { recursive: true });
  } catch (err) {
    return Err({
      reason: "WriteError",
      message: "Failed to create output directory: " + outputDir,
      details: [String(err)],
    });
  }

  // Step 5: Emit files in dependency order
  const outputFiles: string[] = [];
  for (const fileId of graph.emissionOrder) {
    const file = graph.nodes.get(fileId)!;
    const plan = options?.instrumentationPlans?.get(fileId);
    const result = emitFile(file, outputDir, plan);
    if (!result.ok) return result as Result<string[], EmitterError>;
    outputFiles.push(result.value);
  }

  // Step 6: Generate tsconfig.json
  const tsconfigResult = generateTsConfig(outputDir);
  if (!tsconfigResult.ok) return tsconfigResult as Result<string[], EmitterError>;

  // Step 7: Generate package.json
  const entryFile = files.find((f) => f.intent.parent === null);
  const pkgResult = generatePackageJson(outputDir, {
    projectName: options?.projectName || "glass-output",
    version: options?.projectVersion || "0.1.0",
    entryPoint: entryFile ? mapGlassIdToPath(entryFile.id, "").replace(/^\//, "") : undefined,
    externalDependencies: graph.externalDependencies,
  });
  if (!pkgResult.ok) return pkgResult as Result<string[], EmitterError>;

  return Ok(outputFiles);
}

/**
 * Full emit with options object.
 */
export function emitWithOptions(options: EmitterOptions): Result<string[], EmitterError> {
  return emitTypeScript(
    options.files,
    options.verificationResults,
    options.outputDir,
    {
      instrumentationPlans: options.instrumentationPlans,
      projectName: options.projectName,
      projectVersion: options.projectVersion,
      cleanOutput: options.cleanOutput,
    },
  );
}

