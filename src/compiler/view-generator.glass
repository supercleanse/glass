=== Glass Unit ===
id: compiler.view_generator
version: 0.1.0
language: typescript

=== Intent ===
purpose: Generate human-readable views, checklists, and dashboards from Glass units for stakeholder review
source: prd "PRD Section 10"
parent: glass.compiler
stakeholder: user

=== Contract ===
requires:
  - files is a non-empty array of valid GlassFile objects
  - tree is a valid IntentTree with all references resolved
  - results contains a VerificationResult for each file
  - outputDir is a valid writable path

guarantees:
  on_success:
    - Generates per-unit views: intent outline, contract outline, verification checklist
    - Generates aggregate views: business view, security view, verification dashboard
    - Generates master documents: master intent outline, master contract outline
    - All views are valid markdown with auto-generated header
    - Returns array of all generated file paths
  on_failure:
    - Returns ViewGeneratorError with reason and message

invariants:
  - Source .glass files are never modified
  - View generation is deterministic
  - Generated views reflect current state of inputs

fails:
  WriteError: Error(ViewGeneratorError, reason: WriteError)
  InvalidInput: Error(ViewGeneratorError, reason: InvalidInput)

=== Implementation ===
/**
 * Glass View Generator — creates human-readable outlines, checklists,
 * and dashboards from .glass files for stakeholder review.
 *
 * Implements PRD Section 10: generates intent outlines, contract outlines,
 * verification checklists, business views, security views, and dashboards.
 */

import * as fs from "fs";
import * as path from "path";
import type {
  GlassFile,
  IntentTree,
  VerificationResult,
  VerificationAssertion,
  Advisory,
  Result,
} from "../types/index";
import { Ok, Err } from "../types/index";

// ============================================================
// Types
// ============================================================

export interface ViewGeneratorError {
  reason: "WriteError" | "InvalidInput";
  message: string;
  details?: string[];
}

const AUTO_GENERATED_HEADER = "<!-- Auto-generated by Glass Compiler — do not edit directly -->\n\n";

// ============================================================
// Per-Unit Views
// ============================================================

/**
 * Generate an intent outline for a single Glass unit.
 * PRD Section 10 — .intent.md
 */
export function generateIntentOutline(file: GlassFile): string {
  const lines: string[] = [
    AUTO_GENERATED_HEADER,
    "# Intent: " + file.id,
    "",
    "**Purpose:** " + file.intent.purpose,
    "",
    "**Source:** " + formatSource(file),
    "",
    "**Stakeholder:** " + file.intent.stakeholder,
    "",
    "**Parent:** " + (file.intent.parent || "_(root)_"),
    "",
    "**Approval:** " + file.intent.approvalStatus,
    "",
  ];

  if (file.intent.subIntents.length > 0) {
    lines.push("## Sub-Intents");
    lines.push("");
    for (const sub of file.intent.subIntents) {
      const annotations = sub.annotations ? " _(" + sub.annotations.join(", ") + ")_" : "";
      lines.push("- `" + sub.id + "`" + annotations);
    }
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate a contract outline for a single Glass unit.
 * PRD Section 10 — .contract.md
 */
export function generateContractOutline(file: GlassFile): string {
  const lines: string[] = [
    AUTO_GENERATED_HEADER,
    "# Contract: " + file.id,
    "",
  ];

  // Requires
  if (file.contract.requires.length > 0) {
    lines.push("## Preconditions (Requires)");
    lines.push("");
    for (const req of file.contract.requires) {
      lines.push("- " + req.description);
    }
    lines.push("");
  }

  // Guarantees - Success
  if (file.contract.guarantees.onSuccess.length > 0) {
    lines.push("## Guarantees on Success");
    lines.push("");
    for (const g of file.contract.guarantees.onSuccess) {
      lines.push("- " + g.description);
    }
    lines.push("");
  }

  // Guarantees - Failure
  if (file.contract.guarantees.onFailure.length > 0) {
    lines.push("## Guarantees on Failure");
    lines.push("");
    for (const g of file.contract.guarantees.onFailure) {
      lines.push("- " + g.description);
    }
    lines.push("");
  }

  // Invariants
  if (file.contract.invariants.length > 0) {
    lines.push("## Invariants");
    lines.push("");
    for (const inv of file.contract.invariants) {
      lines.push("- " + inv.description);
    }
    lines.push("");
  }

  // Failure Modes
  if (file.contract.fails.length > 0) {
    lines.push("## Failure Modes");
    lines.push("");
    for (const fm of file.contract.fails) {
      lines.push("- **" + fm.errorType + "**: " + fm.handling);
    }
    lines.push("");
  }

  // Advisories
  if (file.contract.advisories.length > 0) {
    lines.push("## Advisories");
    lines.push("");
    for (const adv of file.contract.advisories) {
      const status = adv.resolved ? "RESOLVED" : "OPEN";
      lines.push("- [" + status + "] " + adv.description);
    }
    lines.push("");
  }

  return lines.join("\n");
}

/**
 * Generate a verification checklist for a single unit.
 * PRD Section 9.1 — .verification.md
 */
export function generateVerificationChecklist(result: VerificationResult): string {
  const lines: string[] = [
    AUTO_GENERATED_HEADER,
    "# Verification: " + result.unitId,
    "",
    "**Status:** " + result.status,
    "",
  ];

  const passed = result.assertions.filter((a) => a.passed).length;
  const total = result.assertions.length;
  lines.push("**Assertions:** " + passed + "/" + total + " passed");
  lines.push("");

  // Group by level
  const byLevel = new Map<string, VerificationAssertion[]>();
  for (const a of result.assertions) {
    const group = byLevel.get(a.level) || [];
    group.push(a);
    byLevel.set(a.level, group);
  }

  for (const [level, assertions] of byLevel) {
    lines.push("## " + level);
    lines.push("");
    for (const a of assertions) {
      const icon = a.passed ? "+" : "x";
      lines.push("- [" + icon + "] " + a.assertion);
      lines.push("  - " + a.message);
    }
    lines.push("");
  }

  // Advisories
  if (result.advisories.length > 0) {
    lines.push("## Advisories");
    lines.push("");
    for (const adv of result.advisories) {
      lines.push("- " + adv.description);
    }
    lines.push("");
  }

  return lines.join("\n");
}

// ============================================================
// Aggregate Views
// ============================================================

/**
 * Generate a business-friendly view of the intent tree.
 * PRD Section 10.1 — business-view.md
 * Non-technical, focuses on WHY.
 */
export function generateBusinessView(tree: IntentTree): string {
  const lines: string[] = [
    AUTO_GENERATED_HEADER,
    "# Business View",
    "",
    "## Project Intent Hierarchy",
    "",
  ];

  for (const rootId of tree.roots) {
    renderBusinessTree(lines, tree, rootId, 0);
  }

  return lines.join("\n");
}

function renderBusinessTree(
  lines: string[],
  tree: IntentTree,
  id: string,
  depth: number,
): void {
  const file = tree.files.get(id);
  if (!file) return;

  const indent = "  ".repeat(depth);
  const source = formatSourceBrief(file);
  lines.push(indent + "- **" + file.intent.purpose + "** _(" + source + ")_");

  const children = tree.childrenMap.get(id) || [];
  for (const childId of children) {
    renderBusinessTree(lines, tree, childId, depth + 1);
  }
}

/**
 * Generate a security-focused view.
 * PRD Section 10.2 — security-view.md
 */
export function generateSecurityView(
  files: GlassFile[],
  results: Map<string, VerificationResult>,
): string {
  const lines: string[] = [
    AUTO_GENERATED_HEADER,
    "# Security View",
    "",
  ];

  // Security invariants across all files
  lines.push("## Security Invariants");
  lines.push("");

  for (const file of files) {
    const securityInvariants = file.contract.invariants.filter(
      (inv) => inv.description.toLowerCase().includes("never exposed") ||
        inv.description.toLowerCase().includes("never held") ||
        inv.description.toLowerCase().includes("password") ||
        inv.description.toLowerCase().includes("secret") ||
        inv.description.toLowerCase().includes("encrypt") ||
        inv.description.toLowerCase().includes("token"),
    );

    if (securityInvariants.length > 0) {
      lines.push("### " + file.id);
      lines.push("");
      for (const inv of securityInvariants) {
        const result = results.get(file.id);
        const assertion = result?.assertions.find((a) => a.assertion === inv.description);
        const icon = assertion?.passed ? "+" : "x";
        lines.push("- [" + icon + "] " + inv.description);
      }
      lines.push("");
    }
  }

  // Security-related advisories
  lines.push("## Security Advisories");
  lines.push("");

  for (const file of files) {
    const secAdvisories = file.contract.advisories.filter(
      (adv) => adv.description.toLowerCase().includes("security") ||
        adv.description.toLowerCase().includes("fail-open") ||
        adv.description.toLowerCase().includes("rate") ||
        adv.description.toLowerCase().includes("auth"),
    );

    for (const adv of secAdvisories) {
      lines.push("- **" + file.id + "**: " + adv.description);
    }
  }
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate the verification dashboard.
 * PRD Section 10.3 — verification-dashboard.md
 */
export function generateVerificationDashboard(
  results: Map<string, VerificationResult>,
): string {
  const lines: string[] = [
    AUTO_GENERATED_HEADER,
    "# Verification Dashboard",
    "",
  ];

  let totalUnits = 0;
  let provenUnits = 0;
  let failedUnits = 0;
  let totalAssertions = 0;
  let passedAssertions = 0;
  let totalAdvisories = 0;

  for (const [, result] of results) {
    totalUnits++;
    if (result.status === "PROVEN") provenUnits++;
    else failedUnits++;

    totalAssertions += result.assertions.length;
    passedAssertions += result.assertions.filter((a) => a.passed).length;
    totalAdvisories += result.advisories.length;
  }

  lines.push("## Summary");
  lines.push("");
  lines.push("| Metric | Count |");
  lines.push("|--------|-------|");
  lines.push("| Total Units | " + totalUnits + " |");
  lines.push("| Verified (PROVEN) | " + provenUnits + " |");
  lines.push("| Failed | " + failedUnits + " |");
  lines.push("| Total Assertions | " + totalAssertions + " |");
  lines.push("| Passed Assertions | " + passedAssertions + " |");
  lines.push("| Advisories | " + totalAdvisories + " |");
  lines.push("");

  // Per-unit status
  lines.push("## Per-Unit Status");
  lines.push("");

  for (const [unitId, result] of results) {
    const passed = result.assertions.filter((a) => a.passed).length;
    const total = result.assertions.length;
    const advisoryCount = result.advisories.length;

    let icon: string;
    let suffix = "";
    if (result.status === "FAILED") {
      icon = "x";
      const failed = total - passed;
      suffix = " (" + failed + "/" + total + " assertions failed)";
    } else if (advisoryCount > 0) {
      icon = "!";
      suffix = " (" + passed + "/" + total + " assertions, " + advisoryCount + " advisory)";
    } else {
      icon = "+";
      suffix = " (" + passed + "/" + total + " assertions)";
    }

    lines.push("- [" + icon + "] **" + unitId + "**: " + result.status + suffix);
  }
  lines.push("");

  return lines.join("\n");
}

// ============================================================
// Master Documents
// ============================================================

/**
 * Generate the master intent outline across all units.
 */
export function generateMasterIntentOutline(tree: IntentTree): string {
  const lines: string[] = [
    AUTO_GENERATED_HEADER,
    "# Master Intent Outline",
    "",
  ];

  for (const rootId of tree.roots) {
    renderMasterIntent(lines, tree, rootId, 0);
  }

  return lines.join("\n");
}

function renderMasterIntent(
  lines: string[],
  tree: IntentTree,
  id: string,
  depth: number,
): void {
  const file = tree.files.get(id);
  if (!file) return;

  const indent = "  ".repeat(depth);
  const prefix = depth === 0 ? "## " : indent + "- ";
  lines.push(prefix + file.id + ": " + file.intent.purpose);

  const children = tree.childrenMap.get(id) || [];
  for (const childId of children) {
    renderMasterIntent(lines, tree, childId, depth + 1);
  }

  if (depth === 0) lines.push("");
}

/**
 * Generate the master contract outline across all units.
 */
export function generateMasterContractOutline(files: GlassFile[]): string {
  const lines: string[] = [
    AUTO_GENERATED_HEADER,
    "# Master Contract Outline",
    "",
  ];

  for (const file of files) {
    lines.push("## " + file.id);
    lines.push("");
    lines.push("**Requires:** " + file.contract.requires.map((r) => r.description).join("; "));
    lines.push("");
    lines.push("**Guarantees:** " +
      file.contract.guarantees.onSuccess.map((g) => g.description).join("; "));
    lines.push("");
    if (file.contract.fails.length > 0) {
      lines.push("**Failure Modes:** " +
        file.contract.fails.map((f) => f.errorType).join(", "));
      lines.push("");
    }
  }

  return lines.join("\n");
}

// ============================================================
// File Output
// ============================================================

/**
 * Generate all views and write to the .generated/ directory.
 */
export function generateAllViews(
  files: GlassFile[],
  tree: IntentTree,
  results: Map<string, VerificationResult>,
  outputDir: string,
): Result<string[], ViewGeneratorError> {
  const generatedFiles: string[] = [];

  try {
    fs.mkdirSync(outputDir, { recursive: true });
  } catch (err) {
    return Err({
      reason: "WriteError",
      message: "Failed to create output directory: " + outputDir,
      details: [String(err)],
    });
  }

  // Per-unit views
  for (const file of files) {
    const unitDir = path.join(outputDir, "units");
    fs.mkdirSync(unitDir, { recursive: true });

    const safeId = file.id.replace(/\./g, "_");

    // Intent outline
    const intentPath = path.join(unitDir, safeId + ".intent.md");
    fs.writeFileSync(intentPath, generateIntentOutline(file), "utf-8");
    generatedFiles.push(intentPath);

    // Contract outline
    const contractPath = path.join(unitDir, safeId + ".contract.md");
    fs.writeFileSync(contractPath, generateContractOutline(file), "utf-8");
    generatedFiles.push(contractPath);

    // Verification checklist
    const verResult = results.get(file.id);
    if (verResult) {
      const verPath = path.join(unitDir, safeId + ".verification.md");
      fs.writeFileSync(verPath, generateVerificationChecklist(verResult), "utf-8");
      generatedFiles.push(verPath);
    }
  }

  // Aggregate views
  const businessPath = path.join(outputDir, "business-view.md");
  fs.writeFileSync(businessPath, generateBusinessView(tree), "utf-8");
  generatedFiles.push(businessPath);

  const securityPath = path.join(outputDir, "security-view.md");
  fs.writeFileSync(securityPath, generateSecurityView(files, results), "utf-8");
  generatedFiles.push(securityPath);

  const dashboardPath = path.join(outputDir, "verification-dashboard.md");
  fs.writeFileSync(dashboardPath, generateVerificationDashboard(results), "utf-8");
  generatedFiles.push(dashboardPath);

  // Master documents
  const masterIntentPath = path.join(outputDir, "master-intent-outline.md");
  fs.writeFileSync(masterIntentPath, generateMasterIntentOutline(tree), "utf-8");
  generatedFiles.push(masterIntentPath);

  const masterContractPath = path.join(outputDir, "master-contract-outline.md");
  fs.writeFileSync(masterContractPath, generateMasterContractOutline(files), "utf-8");
  generatedFiles.push(masterContractPath);

  return Ok(generatedFiles);
}

// ============================================================
// Utility
// ============================================================

function formatSource(file: GlassFile): string {
  const src = file.intent.source;
  switch (src.kind) {
    case "prd":
      return "PRD — " + src.reference;
    case "conversation":
      return "Conversation — session " + src.sessionId;
    case "ai-generated":
      return "AI-generated — " + src.reason;
  }
}

function formatSourceBrief(file: GlassFile): string {
  const src = file.intent.source;
  switch (src.kind) {
    case "prd": return "PRD";
    case "conversation": return "conversation";
    case "ai-generated": return "AI-generated";
  }
}
