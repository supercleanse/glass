=== Glass Unit ===
id: cli.cmd_eject
version: 0.1.0
language: typescript

=== Intent ===
purpose: Eject a Glass project to standalone TypeScript code independent of Glass
source: prd reference "PRD Section 12 — glass eject"
parent: glass.cli
stakeholder: user

subIntents: []

=== Contract ===
requires:
  - dist/ directory exists and contains compiled output
  - Output directory is writable

guarantees:
  on_success:
    - Copies all compiled TypeScript from dist/ to output directory
    - Copies tsconfig.json and package.json
    - Creates EJECTED.md documenting the ejection
    - Ejected project is a standalone TypeScript project
    - Exit code is 0
  on_failure:
    - Error message if dist/ is empty or output exists
    - Exit code is 1

invariants:
  - Source .glass files are never modified
  - dist/ directory is never modified (read-only copy)

fails:
  DistNotFound: Error message and exit code 1
  OutputExists: Error message and exit code 1

=== Implementation ===
/** @fails DistNotFound | OutputExists */
/**
 * glass eject — export clean target-language code with no Glass dependencies.
 */

import { Command } from "commander";
import chalk from "chalk";
import * as fs from "fs";
import * as path from "path";

export const ejectCommand = new Command("eject")
  .description("Eject to standalone code with no Glass dependencies")
  .option("-o, --output <dir>", "Output directory for ejected code", "ejected")
  .option("--dist <dir>", "Compiled dist directory", "dist")
  .option("--keep-source", "Keep original Glass source files", false)
  .option("--force", "Skip confirmation prompt", false)
  .action(async (opts) => {
    const distDir = path.resolve(opts.dist);
    const outputDir = path.resolve(opts.output);

    // Verify dist/ exists
    if (!fs.existsSync(distDir)) {
      console.error(
        chalk.red("Error:") + " No compiled output found at " + distDir,
      );
      console.error("Run " + chalk.cyan("glass compile") + " first.");
      process.exitCode = 1;
      return;
    }

    // Verify dist/ has files
    const distFiles = fs.readdirSync(distDir);
    if (distFiles.length === 0) {
      console.error(
        chalk.red("Error:") + " Compiled output directory is empty: " + distDir,
      );
      console.error("Run " + chalk.cyan("glass compile") + " first.");
      process.exitCode = 1;
      return;
    }

    if (!opts.force) {
      console.log(chalk.yellow("Warning:") + " This will create a standalone project without Glass.");
      console.log("The ejected code will not have Glass verification or intent tracking.");
      console.log("Use --force to skip this message.\n");
    }

    // Check if output dir already exists
    if (fs.existsSync(outputDir) && fs.readdirSync(outputDir).length > 0) {
      console.error(
        chalk.red("Error:") + " Output directory already exists and is not empty: " + outputDir,
      );
      process.exitCode = 1;
      return;
    }

    console.log(chalk.blue("Glass") + " Ejecting project...\n");

    // Create output directory
    fs.mkdirSync(outputDir, { recursive: true });

    // Copy all files from dist/ to output/src/
    const srcOut = path.join(outputDir, "src");
    copyDirRecursive(distDir, srcOut);
    const copiedFiles = countFiles(srcOut);
    console.log(chalk.green("  +") + " Copied " + copiedFiles + " files to " + srcOut);

    // Copy tsconfig.json if it exists in dist/
    const tsconfigSrc = path.join(distDir, "tsconfig.json");
    const tsconfigDst = path.join(outputDir, "tsconfig.json");
    if (fs.existsSync(tsconfigSrc)) {
      fs.copyFileSync(tsconfigSrc, tsconfigDst);
      console.log(chalk.green("  +") + " Copied tsconfig.json");
    }

    // Copy package.json if it exists in dist/
    const pkgSrc = path.join(distDir, "package.json");
    const pkgDst = path.join(outputDir, "package.json");
    if (fs.existsSync(pkgSrc)) {
      fs.copyFileSync(pkgSrc, pkgDst);
      console.log(chalk.green("  +") + " Copied package.json");
    }

    // Generate EJECTED.md
    const date = new Date().toISOString().split("T")[0];
    const ejectedMd = `# Ejected from Glass Framework

This project was ejected from the Glass framework on ${date}.

## What this means

- The code in this directory is standalone TypeScript
- There are no dependencies on the Glass framework
- Intent tracking, contract verification, and view generation are no longer active

## Original Glass features that were active

- **Intent Tracking**: Every function had a documented purpose traced to business goals
- **Contract Verification**: Pre/post conditions were verified before code emission
- **Human-Readable Views**: Business, security, and verification dashboards were generated

## If you want to return to Glass

You can re-initialize a Glass project and recreate .glass files from this source code:

\`\`\`
glass init <project-name>
# Then create .glass files wrapping this code
glass verify
glass compile
\`\`\`
`;

    fs.writeFileSync(path.join(outputDir, "EJECTED.md"), ejectedMd, "utf-8");
    console.log(chalk.green("  +") + " Created EJECTED.md");

    // Optionally remove Glass source files
    if (!opts.keepSource) {
      console.log(chalk.gray("\n  Original Glass files preserved (use a new project to start fresh)"));
    }

    console.log("");
    console.log(chalk.green("Ejection complete!"));
    console.log("Output: " + outputDir + "/");
    console.log("\nNext steps:");
    console.log("  cd " + opts.output);
    console.log("  npm install");
    console.log("  npx tsc");
  });

function copyDirRecursive(src: string, dest: string): void {
  fs.mkdirSync(dest, { recursive: true });
  const entries = fs.readdirSync(src, { withFileTypes: true });
  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);
    if (entry.isDirectory()) {
      copyDirRecursive(srcPath, destPath);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}

function countFiles(dir: string): number {
  let count = 0;
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isDirectory()) {
      count += countFiles(path.join(dir, entry.name));
    } else {
      count++;
    }
  }
  return count;
}
