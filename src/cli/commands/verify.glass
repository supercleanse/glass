=== Glass Unit ===
id: cli.cmd_verify
version: 0.1.0
language: typescript

=== Intent ===
purpose: Run contract verification on all Glass files and display results
source: prd reference "PRD Section 12 — glass verify"
parent: glass.cli
stakeholder: user

subIntents: []

=== Contract ===
requires:
  - Current directory or --source flag points to a valid Glass project

guarantees:
  on_success:
    - Displays per-unit verification status with pass/fail counts
    - Verbose mode shows individual assertion details
    - Exit code is 0 when all units pass
  on_failure:
    - Displays error details for failing units
    - Exit code is 1 when any unit fails verification

invariants:
  - Verification is read-only — no files modified

fails:
  ProjectNotFound: Error message and exit code 1
  VerificationFailed: Error details and exit code 1

=== Implementation ===
/** @fails ProjectNotFound | VerificationFailed */
/**
 * glass verify — run contract verification on all .glass files.
 */

import { Command } from "commander";
import chalk from "chalk";
import { loadProject } from "../utils";

export const verifyCommand = new Command("verify")
  .description("Run contract verification on Glass source files")
  .option("-s, --source <dir>", "Source directory", "src")
  .option("--failures-only", "Show only failed units", false)
  .option("-v, --verbose", "Enable verbose output", false)
  .action(async (opts) => {
    console.log(chalk.blue("Glass") + " Verifying...\n");

    const project = loadProject(opts.source);
    if (!project.ok) {
      console.error(chalk.red("Error:") + " " + project.error);
      process.exitCode = 1;
      return;
    }

    const { verificationResults } = project.value;
    let allPassed = true;
    let totalUnits = 0;
    let passedUnits = 0;
    let totalAdvisories = 0;

    for (const [unitId, result] of verificationResults) {
      totalUnits++;
      const passed = result.assertions.filter((a) => a.passed).length;
      const total = result.assertions.length;
      const advisoryCount = result.advisories.length;
      totalAdvisories += advisoryCount;

      if (result.status === "FAILED") {
        allPassed = false;
        const failed = total - passed;
        console.log(chalk.red("  x " + unitId + ": FAILED") + " (" + failed + "/" + total + " assertions failed)");
        if (opts.verbose) {
          for (const a of result.assertions.filter((a) => !a.passed)) {
            console.log(chalk.red("      - " + a.assertion + ": " + a.message));
          }
        }
      } else if (!opts.failuresOnly) {
        passedUnits++;
        if (advisoryCount > 0) {
          console.log(chalk.yellow("  ! " + unitId + ": PROVEN") + " with " + advisoryCount + " advisory");
        } else {
          console.log(chalk.green("  + " + unitId + ": PROVEN") + " (" + passed + "/" + total + " assertions)");
        }
      } else {
        passedUnits++;
      }
    }

    console.log("");
    console.log(chalk.bold("Summary:") + " " + passedUnits + "/" + totalUnits + " units verified" +
      (totalAdvisories > 0 ? ", " + totalAdvisories + " advisories" : ""));

    if (!allPassed) {
      process.exitCode = 1;
    }
  });
