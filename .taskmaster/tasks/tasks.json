{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Initialize Glass Project Structure",
        "description": "Set up the foundational TypeScript project structure with necessary configuration files, directories, and dependencies",
        "details": "Create the initial project structure following Phase 0 (Bootstrap) requirements:\n\n1. Initialize npm project with package.json:\n   - name: @glass-framework/cli\n   - TypeScript as primary language\n   - Dependencies: typescript, @types/node, commander (CLI framework), chalk (terminal output)\n   - Dev dependencies: @types/jest, jest, ts-node, eslint, prettier\n\n2. Create directory structure:\n   - src/ (all .glass files during bootstrap)\n   - src/compiler/ (parser, linker, verifier, emitter)\n   - src/cli/ (command implementations)\n   - src/adapters/ (TypeScript adapter)\n   - src/types/ (TypeScript type definitions)\n   - .generated/ (auto-generated views)\n   - dist/ (compiled output)\n   - .annotations/ (human annotations storage)\n\n3. Configure TypeScript:\n   - tsconfig.json with strict mode enabled\n   - Target: ES2020\n   - Module: CommonJS for CLI, ESM for library exports\n   - outDir: dist/\n\n4. Create placeholder manifest.glass file following the format specified in section 6.1\n\n5. Set up basic .gitignore (node_modules, dist/, .generated/ optional)",
        "testStrategy": "Verify:\n- npm install completes without errors\n- TypeScript compiler runs successfully with tsc --noEmit\n- All directories are created correctly\n- manifest.glass validates against the format specification\n- Project structure matches Section 16 specification",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-01T18:49:38.025Z"
      },
      {
        "id": "2",
        "title": "Create CLAUDE.md Proto-Compiler",
        "description": "Write the comprehensive CLAUDE.md file that serves as the proto-compiler, teaching Claude Code the entire Glass methodology",
        "details": "Create CLAUDE.md following Section 15.3 (Phase 1: The CLAUDE.md Proto-Compiler):\n\n1. Document the complete Glass methodology:\n   - Framework philosophy and core principles (Section 2)\n   - .glass file format specification (Section 4)\n   - Three-layer architecture: Intent, Contract, Implementation (Section 5)\n   - Manifest maintenance rules (Section 6)\n   - Intent hierarchy construction (Section 7)\n   - Contract writing rules and mandatory sections (Section 8)\n\n2. Enforce Glass patterns by convention:\n   - \"Always generate .glass files\"\n   - \"Always maintain the manifest\"\n   - \"Never create implementation without a contract\"\n   - \"Every intent must trace to a source\"\n   - \"Every failure mode must be handled\"\n\n3. Integration instructions:\n   - How to use plan mode as intent bridge (Section 15.6)\n   - How to work with Taskmaster MCP (Section 15.6)\n   - Annotation system workflow\n   - View generation expectations\n\n4. Bootstrap-specific guidance:\n   - Self-hosting strategy\n   - Building toward \"The Ignition\"\n   - Transition from CLAUDE.md-enforced to Glass-enforced\n\n5. Coding standards for TypeScript implementation:\n   - Naming conventions\n   - Error handling patterns\n   - Documentation requirements",
        "testStrategy": "Verify:\n- CLAUDE.md is comprehensive and covers all Glass methodology\n- File format specifications are exact and parseable\n- Claude Code can read and understand the conventions when provided the file\n- All references to PRD sections are accurate\n- Document serves as authoritative reference during Phase 0",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-01T18:49:56.627Z"
      },
      {
        "id": "3",
        "title": "Define Core Type Definitions",
        "description": "Create TypeScript type definitions for all Glass core concepts: intents, contracts, manifests, .glass files, and verification results",
        "details": "Create src/types/core.ts with TypeScript interfaces:\n\n1. GlassFile interface:\n   - id: string (e.g., 'auth.authenticate_user')\n   - version: string (semver)\n   - language: 'typescript' | 'rust'\n   - intent: Intent\n   - contract: Contract\n   - implementation: string (code)\n\n2. Intent interface:\n   - purpose: string\n   - source: IntentSource ('prd' | 'conversation' | 'ai-generated')\n   - parent: string | null\n   - subIntents: string[]\n   - stakeholder: 'user' | 'product' | 'engineering' | 'security'\n   - approvalStatus: 'approved' | 'pending' | 'auto-approved'\n\n3. Contract interface:\n   - requires: ContractAssertion[]\n   - guarantees: { onSuccess: ContractAssertion[], onFailure: ContractAssertion[] }\n   - invariants: ContractAssertion[]\n   - fails: FailureMode[]\n   - advisories: Advisory[]\n\n4. ContractAssertion:\n   - description: string\n   - verificationLevel: 'PROVEN' | 'INSTRUMENTED' | 'TESTED' | 'UNVERIFIABLE'\n\n5. FailureMode:\n   - errorType: string\n   - handling: string\n\n6. Manifest interface (Section 6.1):\n   - projectName: string\n   - version: string\n   - language: string\n   - origins: Origin[]\n   - policies: ApprovalPolicy\n   - intentRegistry: IntentRegistry\n\n7. VerificationResult interface:\n   - unitId: string\n   - status: 'PROVEN' | 'FAILED'\n   - assertions: VerificationAssertion[]\n   - advisories: Advisory[]\n\nEnsure all types are exported and well-documented with JSDoc comments.",
        "testStrategy": "Verify:\n- All types compile without errors\n- Types accurately represent the .glass file format from Section 4\n- Contract structure matches Section 8.2\n- Manifest types match Section 6.1\n- Types can represent all examples shown in the PRD\n- JSDoc comments provide clear usage guidance",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-01T18:53:40.882Z"
      },
      {
        "id": "4",
        "title": "Implement Glass File Format Parser",
        "description": "Build the parser that reads .glass files and extracts intent, contract, and implementation sections into typed TypeScript objects",
        "details": "Create src/compiler/parser.glass (following Glass conventions):\n\n1. Intent:\n   - Purpose: Parse .glass files into structured GlassFile objects\n   - Source: PRD Section 4, bootstrap requirement\n   - Parent: null (foundational unit)\n\n2. Contract:\n   - Requires:\n     * input is valid file path string\n     * file exists and is readable\n     * file follows .glass format (Section 4.1)\n   - Guarantees on success:\n     * Returns valid GlassFile object\n     * All three sections (intent, contract, implementation) extracted\n     * Parsed data matches type definitions\n   - Guarantees on failure:\n     * Returns ParseError with specific reason\n     * Reasons: FileNotFound, InvalidFormat, MissingSection\n   - Invariants:\n     * Original file content never modified\n     * Parser is stateless (no side effects)\n\n3. Implementation:\n   ```typescript\n   // Parsing strategy:\n   // 1. Read file content\n   // 2. Split by section markers (=== Intent ===, etc.)\n   // 3. Parse each section:\n   //    - Intent: YAML-like key-value parsing\n   //    - Contract: Structured outline parsing\n   //    - Implementation: Extract code as-is\n   // 4. Validate all required fields present\n   // 5. Return typed GlassFile object\n   \n   export class GlassParser {\n     parse(filePath: string): Result<GlassFile, ParseError>\n     parseIntent(content: string): Intent\n     parseContract(content: string): Contract\n     parseImplementation(content: string): string\n   }\n   ```\n\n4. Error handling:\n   - Use Result<T, E> pattern (implement if not exists)\n   - Specific error types for each failure mode\n   - Include line numbers in parse errors",
        "testStrategy": "Verify:\n- Parser correctly extracts all sections from valid .glass files\n- Parser handles the example auth.authenticate_user from Section 4.1\n- Parser rejects files missing required sections\n- Parser provides helpful error messages with line numbers\n- Parser handles edge cases (empty sections, malformed YAML)\n- Unit tests cover all success and failure paths\n- Parser output matches GlassFile type definition",
        "priority": "high",
        "dependencies": [
          "3"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Result<T, E> Type and ParseError Types",
            "description": "Create the Result monad utility and all parser-specific error types with line number tracking, forming the error handling foundation for the entire parser",
            "dependencies": [],
            "details": "Create src/compiler/result.ts with a discriminated union Result<T, E> type:\n\n```typescript\nexport type Result<T, E> = { ok: true; value: T } | { ok: false; error: E };\nexport function Ok<T>(value: T): Result<T, never>;\nexport function Err<E>(error: E): Result<never, E>;\n```\n\nCreate src/compiler/parser-errors.ts with specific error types:\n\n```typescript\nexport type ParseErrorReason = 'FileNotFound' | 'InvalidFormat' | 'MissingSection' | 'InvalidSectionContent';\n\nexport interface ParseError {\n  reason: ParseErrorReason;\n  message: string;\n  filePath: string;\n  line?: number;\n  column?: number;\n  section?: 'Glass Unit' | 'Intent' | 'Contract' | 'Implementation';\n}\n```\n\nThe Result type must be reusable across the entire compiler (linker, verifier, emitter all depend on it per Tasks 5, 7, 9). ParseError must carry enough context for helpful diagnostics including file path, line number, and which section failed. Include helper functions: `mapResult`, `flatMapResult`, and `collectResults` for composing Results from sub-parsers. This is the first code written for the project since no src/ directory exists yet — ensure the file structure follows the project layout from PRD Section 16.",
            "status": "pending",
            "testStrategy": "Unit test Ok() and Err() constructors return correct discriminated unions. Test mapResult transforms values correctly and passes through errors. Test collectResults aggregates multiple Results. Verify ParseError carries line numbers and section identifiers. Test that Result type is compatible with TypeScript strict mode.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Section Splitter with Line Tracking",
            "description": "Build the core section-splitting logic that divides raw .glass file content into Glass Unit header, Intent, Contract, and Implementation sections using === markers",
            "dependencies": [
              1
            ],
            "details": "Create the section splitting module within src/compiler/parser.ts (or parser/ directory). The splitter must:\n\n1. Accept raw file content as a string and split by section markers: `=== Glass Unit ===`, `=== Intent ===`, `=== Contract ===`, `=== Implementation ===`\n2. Track line numbers for each section start so parse errors reference the correct location in the source file\n3. Return a `Result<RawSections, ParseError>` where RawSections is:\n```typescript\ninterface RawSections {\n  glassUnit: { content: string; startLine: number };\n  intent: { content: string; startLine: number };\n  contract: { content: string; startLine: number };\n  implementation: { content: string; startLine: number };\n}\n```\n4. Validate all four sections are present — return `ParseError` with reason `MissingSection` if any are absent, identifying which section is missing\n5. Handle edge cases: extra whitespace around markers, blank lines between sections, Windows vs Unix line endings (\\r\\n vs \\n)\n6. Sections must be returned in order of appearance; reject files where sections appear out of order (Glass Unit must come first per PRD Section 4.1)\n7. The regex pattern for markers should be: `/^=== (Glass Unit|Intent|Contract|Implementation) ===$/m`\n\nThis is the foundational parsing step — all subsequent parsers (intent, contract, implementation) consume the output of this splitter.",
            "status": "pending",
            "testStrategy": "Test with the complete auth.authenticate_user example from PRD Section 4.1. Test missing each section individually returns correct MissingSection error with section name. Test extra whitespace and blank lines around markers. Test Windows line endings. Test out-of-order sections are rejected. Test duplicate section markers produce an error. Test completely empty file. Test file with only some markers.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Intent Section Parser and Glass Unit Header Parser",
            "description": "Build parsers for the Glass Unit header (id, version, language) and the Intent section (purpose, source, parent, stakeholder, sub-intents) using YAML-like key-value extraction",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement two sub-parsers that convert raw section content into typed objects:\n\n**Glass Unit Header Parser** — Parse the header block containing:\n- `id: auth.authenticate_user` (required, dotted string)\n- `version: 0.1.0` (required, semver)\n- `language: typescript` (required, 'typescript' | 'rust')\nReturn as a typed GlassUnitHeader matching Task 3's GlassFile top-level fields.\n\n**Intent Section Parser** — Parse the YAML-like intent block:\n- `purpose:` (required, string value)\n- `source:` (required, string — PRD ref, conversation ID, or 'ai-generated')\n- `parent:` (required, string or 'null')\n- `stakeholder:` (optional, 'user' | 'product' | 'engineering' | 'security')\n- `sub-intents:` (optional, list of strings with optional parenthetical annotations like `(ai-generated, security)`)\n\nKey implementation details:\n1. Key-value parsing: split on first `:` only (values may contain colons)\n2. Sub-intents list: lines starting with `  - ` under `sub-intents:` header\n3. Sub-intent annotations in parentheses should be parsed into `{ id: string, annotations?: string[] }`\n4. `parent: null` should be parsed as actual null, not the string 'null'\n5. All parse errors must include line numbers relative to the original file (use startLine offset from section splitter)\n6. Return `Result<Intent, ParseError>` with `InvalidSectionContent` reason on malformed content\n\nReference the Intent interface from Task 3's type definitions (IntentSource, stakeholder enum, etc.).",
            "status": "pending",
            "testStrategy": "Test parsing the complete Intent section from PRD Section 4.1 example. Test each field individually (purpose, source, parent, stakeholder). Test sub-intents list parsing with and without annotations. Test parent: null correctly becomes null. Test missing required fields produce ParseError with line numbers. Test values containing colons (e.g., 'source: conversation/session-1:chat'). Test multi-word purpose values. Test empty sub-intents list.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Contract Section Parser",
            "description": "Build the parser for the Contract section that extracts requires, guarantees (on_success/on_failure), invariants, fails, and advisories into typed Contract objects",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement the contract section parser — the most complex sub-parser due to the nested structure. Parse these subsections from PRD Section 4.1 / 8.2:\n\n1. **requires:** — List of precondition strings (lines starting with `  - `)\n2. **guarantees:** — Nested structure with:\n   - `on_success:` — List of postcondition strings\n   - `on_failure:` — List of postcondition strings (may contain multi-line entries with continuation indentation like `result.reason in [InvalidCredentials, AccountLocked,\\n                         RateLimited, ServiceUnavailable]`)\n3. **invariants:** — List of invariant strings (lines starting with `  - `)\n4. **fails:** — Key-value pairs where key is error type name and value is handling strategy:\n   - Pattern: `ErrorName: handling_description`\n   - Example: `DatabaseUnavailable: retry(3) then Error(ServiceUnavailable)`\n   - Parse into `FailureMode { errorType: string; handling: string }`\n5. **advisories:** — List of advisory strings\n\nImplementation considerations:\n- Detect subsection headers by lines ending with `:` that match known subsection names\n- Handle multi-line list items (continuation lines with deeper indentation)\n- The `fails:` section uses a different format (key: value) than other sections (- list items)\n- Track line numbers for each subsection and each list item for error reporting\n- Return `Result<Contract, ParseError>` matching the Contract interface from Task 3\n- Empty subsections should produce empty arrays, not errors (a unit might have no advisories)\n- Unknown subsection names should produce a warning or error",
            "status": "pending",
            "testStrategy": "Test with the complete Contract section from PRD Section 4.1 auth example. Test each subsection independently (requires, guarantees, invariants, fails, advisories). Test multi-line continuation in on_failure guarantees. Test fails section key-value parsing with various handling strategies. Test empty subsections produce empty arrays. Test missing required subsections (requires and guarantees should be mandatory). Test advisories as optional. Test line number tracking across nested subsections. Test malformed entries produce ParseError with correct line numbers.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement GlassParser Orchestrator with File I/O and Validation",
            "description": "Build the main GlassParser class that orchestrates file reading, section splitting, sub-parsing, validation, and assembly into a complete typed GlassFile object",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create the main `GlassParser` class in src/compiler/parser.ts that ties all sub-parsers together:\n\n```typescript\nexport class GlassParser {\n  parse(filePath: string): Result<GlassFile, ParseError>\n  parseContent(content: string, filePath: string): Result<GlassFile, ParseError>\n  parseIntent(content: string, startLine: number): Result<Intent, ParseError>\n  parseContract(content: string, startLine: number): Result<Contract, ParseError>\n  parseImplementation(content: string, startLine: number): string\n}\n```\n\nOrchestration flow:\n1. **File I/O**: Read file from filePath using fs.readFileSync. Return `ParseError { reason: 'FileNotFound' }` if file doesn't exist. The `parseContent` method allows parsing from a string directly (useful for testing and for other compiler stages).\n2. **Section splitting**: Call the section splitter (subtask 2) to get RawSections\n3. **Glass Unit header parsing**: Parse id, version, language from the Glass Unit section (subtask 3)\n4. **Intent parsing**: Call parseIntent on the intent section content (subtask 3)\n5. **Contract parsing**: Call parseContract on the contract section content (subtask 4)\n6. **Implementation extraction**: Extract the implementation content as-is (raw code string, no transformation)\n7. **Cross-section validation**:\n   - Verify id field is present and non-empty\n   - Verify version is valid semver format\n   - Verify language is a supported value\n   - Verify intent.purpose is non-empty\n   - Verify contract has at least `requires` and `guarantees`\n8. **Assembly**: Construct and return the typed `GlassFile` object matching Task 3's interface\n\nThe parser must be stateless — no instance variables that persist between parse() calls. Each invocation is independent. Export the class as the primary public API of the parser module. Include a convenience function `parseGlassFile(filePath: string): Result<GlassFile, ParseError>` for simple usage.\n\nEnsure the module exports are clean: the GlassParser class, the parseGlassFile function, and re-export Result, ParseError types for consumer convenience.",
            "status": "pending",
            "testStrategy": "Integration test: parse the complete auth.authenticate_user example from PRD Section 4.1 and verify every field of the returned GlassFile object. Test FileNotFound error for non-existent paths. Test parseContent method works without file I/O. Test that parser is stateless (parse two different files sequentially, verify no cross-contamination). Test validation catches missing id, invalid semver, unsupported language. Test implementation section is extracted as raw string without modification. Test that the full GlassFile object matches the type definitions from Task 3. End-to-end test: create a temporary .glass file, parse it, verify the output, clean up.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-01T18:58:20.577Z"
      },
      {
        "id": "5",
        "title": "Implement Intent Tree Linker",
        "description": "Build the linker that resolves parent/child intent relationships and constructs the complete intent hierarchy tree",
        "details": "Create src/compiler/linker.glass:\n\n1. Intent:\n   - Purpose: Build and validate the intent tree from parsed .glass files\n   - Source: PRD Section 11.1 step 2\n   - Parent: compiler (conceptual)\n\n2. Contract:\n   - Requires:\n     * Array of valid GlassFile objects\n     * Each file has unique id\n   - Guarantees on success:\n     * Returns IntentTree with all relationships resolved\n     * All parent references point to existing intents\n     * All sub-intent references point to existing intents\n     * No circular dependencies\n     * Tree has valid root nodes (parent: null)\n   - Guarantees on failure:\n     * Returns LinkError with specific issue\n     * Reasons: DanglingReference, CircularDependency, DuplicateId\n   - Invariants:\n     * Original GlassFile objects unmodified\n     * Tree structure is acyclic\n\n3. Implementation:\n   ```typescript\n   export class IntentLinker {\n     link(files: GlassFile[]): Result<IntentTree, LinkError> {\n       // 1. Build id → file map\n       // 2. For each file:\n       //    - Verify parent exists (or is null)\n       //    - Verify all sub-intents exist\n       // 3. Detect circular dependencies (DFS cycle detection)\n       // 4. Build tree structure\n       // 5. Validate tree properties (connected, acyclic)\n     }\n     \n     findRoots(tree: IntentTree): GlassFile[]\n     getChildren(tree: IntentTree, id: string): GlassFile[]\n     getAncestors(tree: IntentTree, id: string): GlassFile[]\n   }\n   \n   export interface IntentTree {\n     files: Map<string, GlassFile>\n     roots: string[]\n     parentMap: Map<string, string | null>\n     childrenMap: Map<string, string[]>\n   }\n   ```\n\n4. Cycle detection using topological sort or DFS",
        "testStrategy": "Verify:\n- Linker correctly builds tree from valid file set\n- Linker detects dangling parent references\n- Linker detects dangling sub-intent references\n- Linker detects circular dependencies\n- Linker handles multiple root nodes\n- Tree traversal functions work correctly\n- Unit tests cover all error conditions\n- Performance is O(n) for n files",
        "priority": "high",
        "dependencies": [
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-01T19:00:16.372Z"
      },
      {
        "id": "6",
        "title": "Implement Manifest Parser and Manager",
        "description": "Build the manifest.glass parser and manager that tracks requirement origins, approval policies, and intent registry",
        "details": "Create src/compiler/manifest.glass:\n\n1. Intent:\n   - Purpose: Parse, validate, and manage the manifest.glass living requirements document\n   - Source: PRD Section 6\n   - Parent: compiler\n\n2. Contract:\n   - Requires:\n     * manifest.glass file exists at project root\n     * File follows manifest format (Section 6.1)\n   - Guarantees on success:\n     * Returns valid Manifest object\n     * All origins tracked (PRD, conversation, AI-generated)\n     * Approval policies defined\n     * Intent registry accurate\n   - Guarantees on failure:\n     * Returns ManifestError with reason\n   - Invariants:\n     * Manifest version is valid semver\n\n3. Implementation:\n   ```typescript\n   export class ManifestManager {\n     parse(filePath: string): Result<Manifest, ManifestError>\n     \n     // Manifest update methods (for AI to maintain)\n     addIntent(intent: IntentRegistryEntry): void\n     updateApprovalStatus(intentId: string, status: ApprovalStatus): void\n     recordOrigin(origin: Origin): void\n     \n     // Query methods\n     getApprovalPolicy(category: string): 'auto-approve' | 'require-approval'\n     getPendingApprovals(): IntentRegistryEntry[]\n     getIntentsBySource(source: 'prd' | 'conversation' | 'ai-generated'): IntentRegistryEntry[]\n     \n     // Serialization\n     serialize(manifest: Manifest): string\n   }\n   ```\n\n4. Support for conversation tracking (session IDs, user quotes)\n5. Auto-approval policy evaluation",
        "testStrategy": "Verify:\n- Parser handles manifest format from Section 6.1\n- Manager correctly tracks all three origin types\n- Approval policies are enforced\n- Pending approvals are correctly identified\n- Manifest can be serialized and re-parsed identically\n- Unit tests cover all CRUD operations\n- Manager integrates with intent registry",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-01T19:08:49.182Z"
      },
      {
        "id": "7",
        "title": "Implement Basic Contract Verifier",
        "description": "Build the contract verifier with type-level and static analysis verification (Phase 1 scope, formal proof comes later)",
        "details": "Create src/compiler/verifier.glass:\n\n1. Intent:\n   - Purpose: Verify that implementations satisfy their contracts through static analysis\n   - Source: PRD Section 9, Phase 1 verification scope\n   - Parent: compiler\n\n2. Contract:\n   - Requires:\n     * Valid GlassFile with contract and implementation\n     * TypeScript code compiles\n   - Guarantees on success:\n     * Returns VerificationResult with all assertions checked\n     * Each assertion has verification level (PROVEN/INSTRUMENTED/TESTED)\n     * Advisories flagged for human review\n   - Guarantees on failure:\n     * Returns VerificationError with failed assertions\n   - Invariants:\n     * Implementation code not modified\n     * Verification is deterministic\n\n3. Implementation (Phase 1 - Type-level & Static Analysis):\n   ```typescript\n   export class ContractVerifier {\n     verify(file: GlassFile): Result<VerificationResult, VerificationError> {\n       // Phase 1 verification methods:\n       // 1. Type-level guarantees (use TypeScript AST)\n       //    - Function signatures match contract requirements\n       //    - Return types match contract guarantees\n       // 2. Data flow analysis\n       //    - Required inputs are used\n       //    - Guaranteed outputs are produced\n       // 3. Invariant checking\n       //    - Sensitive data not exposed\n       //    - Security patterns followed\n       // 4. Failure mode coverage\n       //    - All declared failure modes have handlers\n       //    - Try/catch blocks map to failure modes\n     }\n     \n     private verifyTypeLevel(file: GlassFile): VerificationAssertion[]\n     private verifyDataFlow(file: GlassFile): VerificationAssertion[]\n     private verifyInvariants(file: GlassFile): VerificationAssertion[]\n     private verifyFailureModes(file: GlassFile): VerificationAssertion[]\n   }\n   ```\n\n4. Use TypeScript compiler API for AST analysis\n5. Mark sophisticated assertions as INSTRUMENTED (defer to Phase 2)\n6. Generate advisories for human review when uncertainty exists",
        "testStrategy": "Verify:\n- Verifier analyzes TypeScript AST correctly\n- Type-level checks match contract requirements\n- Failure mode coverage is complete\n- Verifier handles the auth example from Section 17\n- Verification results match format from Section 9.1\n- Assertions are categorized correctly by level\n- Unit tests for each verification method\n- Integration test with parser and linker",
        "priority": "high",
        "dependencies": [
          "4",
          "5"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up TypeScript Compiler API Integration and AST Utility Layer",
            "description": "Create the foundational TypeScript Compiler API integration module that the verifier uses to parse and analyze implementation code from GlassFile objects.",
            "dependencies": [],
            "details": "Create src/compiler/verifier/ts-ast-utils.ts with TypeScript Compiler API integration:\n\n1. **Program creation from GlassFile**: Build a function `createProgramFromSource(code: string, fileName?: string): ts.Program` that creates an in-memory TypeScript program from the implementation section of a GlassFile. Use `ts.createCompilerHost` with a custom `getSourceFile` that returns the in-memory source. Configure compiler options with strict mode enabled (matching the project's tsconfig from Task 1).\n\n2. **AST traversal utilities**:\n   - `findFunctions(sourceFile: ts.SourceFile): FunctionInfo[]` — Extract all function/method declarations with their names, parameter types, return types, and modifiers (exported, async, etc.)\n   - `findTryCatchBlocks(sourceFile: ts.SourceFile): TryCatchInfo[]` — Locate all try/catch blocks with their catch clause error types and the code ranges they cover\n   - `findIdentifierUsages(sourceFile: ts.SourceFile, name: string): ts.Node[]` — Find all references to a named identifier in the AST\n   - `findReturnStatements(node: ts.Node): ts.ReturnStatement[]` — Collect all return statements within a function/method body\n   - `findPropertyAccesses(sourceFile: ts.SourceFile, objectName: string): PropertyAccessInfo[]` — Track property access chains (e.g., `result.session.userId`)\n   - `getTypeAtNode(program: ts.Program, node: ts.Node): ts.Type` — Use the TypeChecker to resolve the type at any AST node\n\n3. **Type extraction helpers**:\n   - `extractFunctionSignature(func: ts.FunctionDeclaration | ts.MethodDeclaration): FunctionSignature` — returns `{ name, params: {name, type}[], returnType, isAsync }`\n   - `isTypeAssignableTo(program: ts.Program, source: ts.Type, target: ts.Type): boolean` — leverage TypeChecker to check type compatibility\n\n4. **Interface definitions** for all return types (FunctionInfo, TryCatchInfo, PropertyAccessInfo, FunctionSignature).\n\n5. **Diagnostics collection**: `getDiagnostics(program: ts.Program): ts.Diagnostic[]` — verify the implementation compiles before attempting verification (a precondition of the verifier contract).\n\nThe `typescript` package is already a project dependency (from Task 1). This module is purely utility — it contains no verification logic, only AST access primitives that all four verification methods will use.",
            "status": "pending",
            "testStrategy": "Unit test createProgramFromSource with a simple TypeScript function string and verify the program has zero diagnostics. Test findFunctions extracts correct names, parameter types, and return types from multi-function source. Test findTryCatchBlocks correctly identifies nested try/catch with typed catch clauses. Test findIdentifierUsages finds all references including within nested scopes. Test findReturnStatements collects returns from both early-return and end-of-function positions. Test getTypeAtNode resolves basic types (string, number, custom interfaces). Test getDiagnostics returns errors for invalid TypeScript. Test with the auth example implementation code pattern from PRD Section 17.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Type-Level Verification and Data Flow Analysis",
            "description": "Build the verifyTypeLevel and verifyDataFlow private methods that check function signatures against contract requirements/guarantees and verify that declared inputs are consumed and outputs are produced.",
            "dependencies": [
              1
            ],
            "details": "Create src/compiler/verifier/type-verifier.ts and src/compiler/verifier/dataflow-verifier.ts:\n\n**Type-Level Verification (`verifyTypeLevel`)**:\nAnalyze the implementation's TypeScript AST against the GlassFile's contract `requires` and `guarantees` sections:\n\n1. **Parameter matching**: For each `requires` assertion like `input.email is String`, find the main exported function(s) and verify:\n   - A parameter named `input` (or matching the contract's object name) exists\n   - The parameter type has a property `email` of type `string`\n   - Use the TypeChecker from subtask 1 to resolve structural types, not just name matching\n2. **Return type matching**: For each `guarantees.on_success` assertion like `result is AuthSuccess`, verify:\n   - The function's return type (or Promise<> unwrapped return type for async) includes `AuthSuccess` as a possible type\n   - For union return types (Result<AuthSuccess, AuthFailure>), verify the success branch matches\n3. **Failure return matching**: For each `guarantees.on_failure` assertion like `result is AuthFailure`, verify the failure branch of the return type matches\n4. **Assertion level assignment**: Mark type-checkable assertions as `PROVEN` when the TypeChecker confirms them. Mark assertions that reference runtime state (e.g., `system.database is Active`) as `INSTRUMENTED` since these cannot be proven at compile time.\n\n**Data Flow Analysis (`verifyDataFlow`)**:\nPerform lightweight data flow analysis on the AST:\n\n1. **Input usage**: For each `requires` assertion referencing an input parameter, verify the parameter is actually used in the function body (not just declared). Use `findIdentifierUsages` from subtask 1.\n2. **Output production**: For each `guarantees.on_success` assertion referencing an output property (e.g., `result.session`), verify that the success path actually constructs/assigns that property. Walk return statements and check property assignments.\n3. **Unused inputs warning**: If a declared contract `requires` input is never referenced in the implementation, generate an advisory (this may indicate a contract/implementation mismatch).\n4. **Missing outputs warning**: If a guaranteed output property is never assigned in any return path, flag as a verification failure.\n\nBoth methods return `VerificationAssertion[]` using the type from Task 3 (core types). Each assertion includes: the original contract assertion text, the verification level (PROVEN/INSTRUMENTED), and a message explaining the verification result.",
            "status": "pending",
            "testStrategy": "Test type-level verification with a function that has typed parameters matching contract requires — expect PROVEN assertions. Test with mismatched types (contract says String, param is number) — expect FAILED assertion. Test async function return type unwrapping (Promise<Result<A,B>>). Test data flow with a function that uses all declared inputs — expect PROVEN. Test with an unused input parameter — expect advisory generated. Test with a success path that doesn't construct a guaranteed output property — expect failure. Test with the auth.authenticate_user example: verify input.email, input.password are used, result.session is produced. Test that runtime preconditions (system.database is Active) are correctly marked INSTRUMENTED not PROVEN.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Invariant Checking and Failure Mode Coverage Analysis",
            "description": "Build the verifyInvariants and verifyFailureModes private methods that check security invariants against the AST and verify all declared failure modes have corresponding error handlers.",
            "dependencies": [
              1
            ],
            "details": "Create src/compiler/verifier/invariant-verifier.ts and src/compiler/verifier/failure-mode-verifier.ts:\n\n**Invariant Checking (`verifyInvariants`)**:\nVerify contract `invariants` against the implementation AST using pattern-based static analysis:\n\n1. **Sensitive data exposure detection**: For invariants like `user.password_hash never exposed in output or logs`:\n   - Find all references to the sensitive field (e.g., `password_hash`) using `findIdentifierUsages`\n   - Check that sensitive fields are NOT passed to: return statements, console.log/warn/error calls, any function named `log*`, response object assignments, JSON.stringify calls\n   - Mark as PROVEN if the sensitive field is only used in comparison operations (e.g., `bcrypt.compare`)\n   - Mark as INSTRUMENTED if the analysis cannot definitively determine all usage paths (e.g., passed to an opaque function)\n2. **Memory safety patterns**: For invariants like `password_hash never held in memory after comparison`:\n   - Check if the variable holding sensitive data is reassigned to null/undefined after its comparison use\n   - This is heuristic-based in Phase 1 — mark as INSTRUMENTED with advisory explaining the limitation\n3. **Security pattern detection**: For invariants referencing patterns like `rate_limit.state correctly updated`:\n   - Verify the referenced state variable is written to in the implementation\n   - Mark as INSTRUMENTED since correctness of the update logic requires deeper analysis (Phase 2)\n4. **Generic invariant handling**: For invariants the analyzer doesn't have specific rules for, mark as INSTRUMENTED and generate an advisory for human review.\n\n**Failure Mode Coverage (`verifyFailureModes`)**:\nVerify that every `fails` entry in the contract has a corresponding handler in the implementation:\n\n1. **Try/catch mapping**: Use `findTryCatchBlocks` to enumerate all error handling in the implementation\n2. **Error type matching**: For each declared failure mode (e.g., `DatabaseUnavailable: retry(3) then Error(ServiceUnavailable)`):\n   - Search catch clauses for references to the error type name\n   - Search for conditional checks (instanceof, error.code, error.name) that match the failure mode\n   - Check that the handling strategy is reflected (e.g., retry logic exists, correct error is thrown/returned)\n3. **Coverage completeness**: \n   - Each contract failure mode must map to at least one catch clause or error conditional\n   - Unmapped failure modes are verification failures (not just advisories)\n4. **Orphan catch detection**: Identify catch blocks that don't map to any declared failure mode — generate an advisory suggesting the contract may be incomplete\n5. **Assertion levels**: Mark failure modes with clear catch clause mapping as PROVEN. Mark failure modes where the handling strategy can't be fully verified (e.g., retry count) as INSTRUMENTED.\n\nBoth methods return `VerificationAssertion[]` consistent with the verification result types from Task 3.",
            "status": "pending",
            "testStrategy": "Test invariant checking: create implementation that passes password_hash to console.log — expect FAILED. Create implementation that only uses password_hash in bcrypt.compare — expect PROVEN. Create implementation with password set to null after use — verify detection. Test failure mode coverage: create implementation with try/catch handling DatabaseUnavailable — expect PROVEN. Create implementation missing a handler for a declared failure mode — expect FAILED assertion. Test orphan catch detection with a catch block for an undeclared error type — expect advisory. Test with the auth example: verify all 4 failure modes (DatabaseUnavailable, SessionStoreUnavailable, RateLimitExceeded, UnexpectedError) are detected as handled. Test generic invariant fallback produces INSTRUMENTED level with advisory.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Build the ContractVerifier Orchestrator and Verification Result Aggregator",
            "description": "Create the main ContractVerifier class that orchestrates all four verification methods, aggregates results into a VerificationResult, and generates advisories for human review.",
            "dependencies": [
              2,
              3
            ],
            "details": "Create src/compiler/verifier/index.ts (main verifier module) with the `ContractVerifier` class:\n\n```typescript\nexport class ContractVerifier {\n  verify(file: GlassFile): Result<VerificationResult, VerificationError>\n  private verifyTypeLevel(file: GlassFile): VerificationAssertion[]\n  private verifyDataFlow(file: GlassFile): VerificationAssertion[]\n  private verifyInvariants(file: GlassFile): VerificationAssertion[]\n  private verifyFailureModes(file: GlassFile): VerificationAssertion[]\n}\n```\n\n**Orchestration flow in `verify()`**:\n1. **Precondition check**: Validate the GlassFile has both a contract and implementation section. Return `VerificationError` if missing.\n2. **Compilation check**: Use `createProgramFromSource` (subtask 1) to create a TS program from the implementation. Check `getDiagnostics` — if TypeScript doesn't compile, return `VerificationError` with the compilation errors. This satisfies the contract precondition \"TypeScript code compiles\".\n3. **Run all four verification methods** sequentially, collecting `VerificationAssertion[]` from each:\n   - `verifyTypeLevel(file)` — delegates to type-verifier.ts (subtask 2)\n   - `verifyDataFlow(file)` — delegates to dataflow-verifier.ts (subtask 2)\n   - `verifyInvariants(file)` — delegates to invariant-verifier.ts (subtask 3)\n   - `verifyFailureModes(file)` — delegates to failure-mode-verifier.ts (subtask 3)\n4. **Aggregate results**: Merge all assertions into a single `VerificationResult`:\n   - `unitId`: from `file.id`\n   - `assertions`: all collected assertions\n   - `status`: `PROVEN` if all assertions passed (any level), `FAILED` if any assertion failed\n   - `advisories`: collected from all methods (INSTRUMENTED items get advisories explaining what Phase 2 will prove)\n5. **Advisory generation**: Create advisories for:\n   - Every INSTRUMENTED assertion (explain why it couldn't be proven statically)\n   - Every UNVERIFIABLE assertion (recommend human review)\n   - Contract advisories passed through from the GlassFile's `contract.advisories` section\n6. **Determinism guarantee**: The verify method must be pure — same GlassFile input always produces same VerificationResult. No random elements, no system state dependencies.\n7. **Immutability guarantee**: The input GlassFile must not be modified. Use the TS program copy, never mutate the original.\n\n**Error types**:\n```typescript\nexport interface VerificationError {\n  unitId: string;\n  reason: 'MissingContract' | 'MissingImplementation' | 'CompilationFailed' | 'VerificationFailed';\n  message: string;\n  failedAssertions?: VerificationAssertion[];\n  compilationErrors?: string[];\n}\n```\n\nExport `ContractVerifier` as the public API. Also export a convenience function `verifyContract(file: GlassFile): Result<VerificationResult, VerificationError>` for simple usage. Re-export all verification types for consumer convenience.",
            "status": "pending",
            "testStrategy": "Integration test: verify a well-formed GlassFile with matching implementation — expect VerificationResult with status PROVEN and all assertions passed. Test with GlassFile missing contract — expect VerificationError with reason MissingContract. Test with GlassFile whose implementation has TypeScript errors — expect VerificationError with reason CompilationFailed and diagnostic messages. Test with GlassFile where one contract assertion fails — expect status FAILED with the specific assertion identified. Test determinism: verify the same GlassFile twice and assert identical results. Test immutability: deep-clone GlassFile before and after verify, assert equality. Test advisory generation: verify a file with INSTRUMENTED assertions generates corresponding advisories. End-to-end test with the auth.authenticate_user example from PRD Section 17: parse the example .glass content, run verify, confirm results match the verification checklist format from Section 9.1 (15 assertions verified, 1 advisory).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Runtime Instrumentation Injector for Unproven Assertions",
            "description": "Build the instrumentation module that generates runtime check code to be injected into emitted output for assertions that could not be statically proven (INSTRUMENTED level).",
            "dependencies": [
              4
            ],
            "details": "Create src/compiler/verifier/instrumentor.ts:\n\nThis module takes a VerificationResult and generates runtime assertion code that the emitter (Task 9) will inject into the output TypeScript for any INSTRUMENTED assertions:\n\n1. **Instrumentation code generation**:\n   ```typescript\n   export interface InstrumentationPlan {\n     unitId: string;\n     checks: RuntimeCheck[];\n   }\n   \n   export interface RuntimeCheck {\n     assertionText: string;\n     verificationLevel: 'INSTRUMENTED';\n     checkCode: string;       // TypeScript code for the runtime check\n     insertionPoint: 'pre' | 'post' | 'invariant';  // where to inject\n     errorMessage: string;\n   }\n   \n   export function generateInstrumentation(\n     file: GlassFile,\n     result: VerificationResult\n   ): InstrumentationPlan\n   ```\n\n2. **Pre-condition checks** (insertion point: 'pre'): For INSTRUMENTED `requires` assertions (e.g., `system.database is Active`), generate runtime checks at function entry:\n   ```typescript\n   // Generated check for: system.database is Active\n   if (!system?.database?.isActive?.()) {\n     throw new GlassContractViolation('Precondition failed: system.database is Active');\n   }\n   ```\n\n3. **Post-condition checks** (insertion point: 'post'): For INSTRUMENTED `guarantees` assertions, generate checks before return statements:\n   ```typescript\n   // Generated check for: result.session.userId == verified_user.id\n   if (result.session?.userId !== verified_user?.id) {\n     throw new GlassContractViolation('Postcondition failed: result.session.userId == verified_user.id');\n   }\n   ```\n\n4. **Invariant checks** (insertion point: 'invariant'): For INSTRUMENTED invariants, generate checks at relevant code points:\n   ```typescript\n   // Generated check for: password_hash never held in memory after comparison\n   // Inserted after comparison block\n   passwordHash = null; // enforce memory clearing\n   ```\n\n5. **GlassContractViolation error class**: Generate a custom error class definition that all runtime checks use:\n   ```typescript\n   export class GlassContractViolation extends Error {\n     constructor(public assertion: string) {\n       super(`Glass contract violation: ${assertion}`);\n       this.name = 'GlassContractViolation';\n     }\n   }\n   ```\n\n6. **Integration with emitter**: The InstrumentationPlan is consumed by the TypeScript emitter (Task 9) which handles actual code injection. This module only generates the plan — it does NOT modify the GlassFile or its implementation (preserving the verifier's immutability invariant).\n\n7. **Instrumentation summary**: Include a method `summarizeInstrumentation(plan: InstrumentationPlan): string` that produces a human-readable summary of what runtime checks will be injected, for inclusion in verification checklists and advisories.\n\nThis is Phase 1's answer to assertions that can't be statically proven — instead of rejecting the code, inject runtime guards that enforce the contract at execution time. Phase 2 will replace many of these with formal proofs via SMT solver integration.",
            "status": "pending",
            "testStrategy": "Test generateInstrumentation with a VerificationResult containing INSTRUMENTED preconditions — verify generated check code is syntactically valid TypeScript. Test that PROVEN assertions are NOT instrumented (no runtime checks generated for them). Test postcondition check generation for return type assertions. Test invariant instrumentation for memory-clearing patterns. Test GlassContractViolation error class is included in the plan when any checks are generated. Test summarizeInstrumentation produces readable output listing all injected checks. Test with a VerificationResult that has zero INSTRUMENTED assertions — expect empty checks array. Integration test: generate instrumentation for the auth example's rate_limit advisory — verify appropriate runtime check is generated. Verify the module never modifies the input GlassFile (immutability contract).",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-01T19:03:41.663Z"
      },
      {
        "id": "8",
        "title": "Implement View Generator",
        "description": "Build the view generator that creates human-readable outlines, checklists, and dashboards from .glass files",
        "details": "Create src/compiler/view-generator.glass:\n\n1. Intent:\n   - Purpose: Generate all human-readable views and dashboards for stakeholder review\n   - Source: PRD Section 10\n   - Parent: compiler\n\n2. Contract:\n   - Requires:\n     * Valid GlassFile objects\n     * IntentTree\n     * VerificationResult for each file\n   - Guarantees on success:\n     * Generates all views to .generated/ directory\n     * Views are valid markdown\n     * Views are synchronized with source .glass files\n   - Guarantees on failure:\n     * Returns ViewGenerationError\n   - Invariants:\n     * Source .glass files never modified\n     * Generated files clearly marked as auto-generated\n\n3. Implementation:\n   ```typescript\n   export class ViewGenerator {\n     generateAll(files: GlassFile[], tree: IntentTree, results: Map<string, VerificationResult>): void\n     \n     // Per-unit views (Section 10)\n     generateIntentOutline(file: GlassFile): string // .intent.md\n     generateContractOutline(file: GlassFile): string // .contract.md\n     generateVerificationChecklist(result: VerificationResult): string // .verification.md\n     \n     // Aggregate views\n     generateBusinessView(tree: IntentTree): string // business-view.md\n     generateSecurityView(files: GlassFile[], results: Map<...>): string // security-view.md\n     generateVerificationDashboard(results: Map<...>): string // verification-dashboard.md\n     \n     // Master documents\n     generateMasterIntentOutline(tree: IntentTree): string\n     generateMasterContractOutline(files: GlassFile[]): string\n     generateMasterVerificationStatus(results: Map<...>): string\n   }\n   ```\n\n4. Templates for each view type matching PRD examples\n5. Markdown formatting with checkboxes (✓, ✗, ⚠)\n6. Support for annotations display",
        "testStrategy": "Verify:\n- All view types generate valid markdown\n- Intent outlines match format from Section 7.1\n- Contract outlines match format from Section 8.1\n- Verification checklists match format from Section 9.1\n- Business view is non-technical (Section 10.1)\n- Security view highlights security posture (Section 10.2)\n- Verification dashboard shows roll-up status (Section 10.3)\n- Generated files have auto-generated warning headers\n- Views accurately reflect source .glass files",
        "priority": "medium",
        "dependencies": [
          "4",
          "5",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-01T19:11:03.353Z"
      },
      {
        "id": "9",
        "title": "Implement TypeScript Code Emitter",
        "description": "Build the code emitter that outputs clean, standard TypeScript code from .glass files",
        "details": "Create src/compiler/emitter.glass:\n\n1. Intent:\n   - Purpose: Emit clean, standard TypeScript code to dist/ directory\n   - Source: PRD Section 11.1 step 6\n   - Parent: compiler\n\n2. Contract:\n   - Requires:\n     * Valid GlassFile objects\n     * All files have passed verification\n   - Guarantees on success:\n     * Outputs standard TypeScript to dist/\n     * Generated code compiles with tsc\n     * No Glass-specific constructs in output\n     * Output is idiomatic TypeScript\n   - Guarantees on failure:\n     * Returns EmitterError\n     * No partial output written\n   - Invariants:\n     * Emitted code functionally equivalent to implementation section\n     * Source .glass files not modified\n\n3. Implementation:\n   ```typescript\n   export class TypeScriptEmitter {\n     emit(files: GlassFile[], outputDir: string): Result<void, EmitterError> {\n       // 1. Extract implementation from each .glass file\n       // 2. Write to corresponding .ts file in dist/\n       // 3. Generate package.json for dist/\n       // 4. Generate tsconfig.json for dist/\n       // 5. Ensure all imports/exports work\n     }\n     \n     private emitFile(file: GlassFile, outputPath: string): void\n     private generatePackageJson(projectName: string, version: string): void\n     private generateTsConfig(): void\n   }\n   ```\n\n4. Preserve source maps (for debugging)\n5. Handle module resolution and imports\n6. Generate deployment-ready package.json",
        "testStrategy": "Verify:\n- Emitted TypeScript compiles with tsc\n- Output matches examples in Section 17.3\n- Generated package.json is valid\n- Generated tsconfig.json works\n- No Glass-specific artifacts in output\n- Code can be deployed to standard platforms\n- Verification: run tsc on emitted code\n- Verification: npm install works in dist/",
        "priority": "high",
        "dependencies": [
          "4",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Build Module Dependency Graph and Import/Export Resolver",
            "description": "Create the module dependency analysis layer that scans GlassFile implementations for import/export statements, builds a dependency graph, rewrites Glass-internal references (e.g., from .glass paths to .ts paths), and resolves cross-unit module relationships for correct emission ordering.",
            "dependencies": [],
            "details": "Create src/compiler/emitter/dependency-resolver.ts:\n\nThis module analyzes all GlassFile implementations to understand their inter-dependencies before any files are written, ensuring correct emission ordering and valid import paths in the output.\n\n```typescript\nexport interface ModuleDependency {\n  sourceId: string;           // GlassFile id of the importing unit\n  targetId: string;           // GlassFile id of the imported unit\n  importStatement: string;    // Original import statement\n  rewrittenImport: string;    // Rewritten import with .ts-relative path\n}\n\nexport interface DependencyGraph {\n  nodes: Map<string, GlassFile>;       // id -> GlassFile\n  edges: ModuleDependency[];           // All import relationships\n  emissionOrder: string[];             // Topological order for emission\n}\n\nexport class DependencyResolver {\n  resolve(files: GlassFile[]): Result<DependencyGraph, EmitterError>\n  private extractImports(implementation: string): ImportStatement[]\n  private rewriteImportPath(originalPath: string, sourceFile: GlassFile, targetFile: GlassFile, outputDir: string): string\n  private topologicalSort(nodes: Map<string, GlassFile>, edges: ModuleDependency[]): Result<string[], EmitterError>\n}\n```\n\nKey implementation details:\n1. **Import extraction**: Parse the implementation section of each GlassFile using regex or TypeScript AST (from Task 7's ts-ast-utils) to find all `import` and `require()` statements. Categorize as: (a) internal Glass imports (reference other .glass units), (b) external npm imports (pass through unchanged), (c) relative path imports.\n2. **Path rewriting**: Convert Glass-internal import paths from the src/ .glass layout to the dist/ .ts layout. For example, if `authenticate_user.glass` imports from `validate_credentials.glass`, the emitted import should reference `./validate_credentials` (relative .ts path in dist/). The .glass file `id` field (e.g., `auth.validate_credentials`) maps to the output path `auth/validate_credentials.ts`.\n3. **Topological sort**: Compute emission order using topological sort on the dependency graph. If circular dependencies exist (which the linker in Task 5 should have already rejected), return an EmitterError. This ordering is informational — TypeScript handles circular imports at runtime — but ensures predictable output.\n4. **Export analysis**: Identify what each GlassFile exports (functions, classes, types) by scanning for `export` keywords. This informs the package.json entry point generation (subtask 4).\n5. **External dependency collection**: Collect all external npm package imports across all files (e.g., `bcrypt`, `express`) for inclusion in the generated package.json dependencies.\n\nThe DependencyGraph is consumed by both the file emitter (subtask 2) for import rewriting and the package.json generator (subtask 4) for dependency listing.",
            "status": "pending",
            "testStrategy": "Test import extraction from implementation code containing: ES module imports (`import { foo } from './bar'`), default imports, namespace imports (`import * as`), require() calls, and type-only imports. Test path rewriting: verify that Glass unit id `auth.validate_credentials` maps to correct relative path from `auth/authenticate_user.ts`. Test topological sort returns correct ordering for a linear dependency chain (A -> B -> C). Test that external npm imports (e.g., `import bcrypt from 'bcrypt'`) are passed through unchanged and collected as external dependencies. Test that circular dependency produces an EmitterError. Test with the auth system example from PRD Section 17: 6 files with cross-unit imports should produce a valid dependency graph and emission order.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Individual .ts File Emitter with Implementation Extraction",
            "description": "Build the core file emission logic that extracts the implementation section from each GlassFile, applies import rewrites from the dependency resolver, injects runtime instrumentation checks (from the verifier's InstrumentationPlan), strips any Glass-specific constructs, and writes clean idiomatic TypeScript to the output directory.",
            "dependencies": [
              1
            ],
            "details": "Create src/compiler/emitter/file-emitter.ts:\n\nThis is the core emission unit — it takes a single GlassFile and produces a single .ts file in the output directory.\n\n```typescript\nexport interface EmitFileOptions {\n  file: GlassFile;\n  outputPath: string;                           // Absolute path to output .ts file\n  dependencyGraph: DependencyGraph;             // From subtask 1\n  instrumentationPlan?: InstrumentationPlan;    // From Task 7 verifier\n  sourceMapEnabled: boolean;\n}\n\nexport class FileEmitter {\n  emitFile(options: EmitFileOptions): Result<void, EmitterError>\n  private extractImplementation(file: GlassFile): string\n  private rewriteImports(code: string, graph: DependencyGraph, fileId: string): string\n  private injectInstrumentation(code: string, plan: InstrumentationPlan): string\n  private stripGlassArtifacts(code: string): string\n  private addAutoGeneratedHeader(code: string, file: GlassFile): string\n  private generateSourceMap(originalCode: string, emittedCode: string, sourcePath: string, outputPath: string): string\n}\n```\n\nKey implementation details:\n1. **Implementation extraction**: Pull the raw code from `file.implementation`. This is the direct code content — the implementation section of the .glass file IS the TypeScript code. No transformation is needed beyond import rewriting and optional instrumentation injection.\n2. **Import rewriting**: Use the DependencyGraph from subtask 1 to replace all Glass-internal import paths with correct relative .ts paths in the output directory. External imports remain unchanged.\n3. **Instrumentation injection**: If an InstrumentationPlan exists for this file (from Task 7's instrumentor), inject the runtime checks at the specified insertion points (pre, post, invariant). Pre-condition checks go at function entry. Post-condition checks wrap return statements. Include the GlassContractViolation error class import at the top if any checks are injected.\n4. **Glass artifact stripping**: Scan the emitted code for any Glass-specific constructs that shouldn't appear in output — comments referencing Glass internals, Glass-specific type annotations, etc. The implementation section should already be clean TypeScript, but this is a safety pass.\n5. **Auto-generated header**: Add a comment header to each emitted file: `// Generated by Glass Compiler v{version} — do not edit directly` with a reference to the source .glass file id.\n6. **Source map generation**: When enabled, produce an inline or separate `.ts.map` file that maps the emitted .ts line numbers back to the original .glass file line numbers (offset by the implementation section's start line). Use the standard Source Map v3 format.\n7. **Atomic write**: Write the file using a temp file + rename pattern to ensure no partial output is written (satisfying the contract's 'no partial output' guarantee). If the write fails, clean up the temp file and return EmitterError.\n8. **Output path computation**: Convert GlassFile id (e.g., `auth.authenticate_user`) to output path: `dist/auth/authenticate_user.ts`. Create intermediate directories as needed.\n\nThe FileEmitter does NOT write package.json or tsconfig.json — those are handled by subtasks 3 and 4.",
            "status": "pending",
            "testStrategy": "Test implementation extraction: verify that the implementation section of a GlassFile is extracted verbatim. Test import rewriting: create a GlassFile with `import { validate } from '../auth/validate_credentials.glass'` and verify it becomes `import { validate } from './validate_credentials'` in the output. Test Glass artifact stripping: inject a `// Glass:internal` comment and verify it is removed. Test auto-generated header is present and contains the file id. Test atomic write: simulate a write failure (read-only directory) and verify no partial file exists. Test output path computation: `auth.authenticate_user` -> `dist/auth/authenticate_user.ts`. Test with instrumentation: provide an InstrumentationPlan with a precondition check and verify the check code appears at the function entry point. Test source map generation: verify the .map file is valid JSON with correct mappings. End-to-end: emit the auth.authenticate_user example and verify the output is compilable by tsc.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement tsconfig.json Generator for dist/ Output",
            "description": "Build the tsconfig.json generator that produces a valid TypeScript compiler configuration for the dist/ directory, ensuring that emitted code compiles cleanly with `tsc` and follows the project's target configuration (ES2020, strict mode, correct module settings).",
            "dependencies": [],
            "details": "Create src/compiler/emitter/tsconfig-generator.ts:\n\n```typescript\nexport interface TsConfigOptions {\n  outputDir: string;              // dist/ directory path\n  projectConfig?: GlassConfig;    // From glass.config.json if available\n  files: GlassFile[];             // All emitted files (for 'files' or 'include' array)\n  moduleSystem: 'commonjs' | 'esnext';  // Target module system\n}\n\nexport class TsConfigGenerator {\n  generate(options: TsConfigOptions): Result<void, EmitterError>\n  private buildConfig(options: TsConfigOptions): TsConfigJson\n  private writeConfig(config: TsConfigJson, outputDir: string): Result<void, EmitterError>\n}\n\ninterface TsConfigJson {\n  compilerOptions: {\n    target: string;           // ES2020 per PRD\n    module: string;           // CommonJS for CLI, ESM for library\n    strict: boolean;          // Always true\n    esModuleInterop: boolean;\n    skipLibCheck: boolean;\n    forceConsistentCasingInFileNames: boolean;\n    outDir: string;           // './compiled' or similar for further compilation\n    declaration: boolean;     // Generate .d.ts files\n    declarationMap: boolean;  // Source maps for declarations\n    sourceMap: boolean;       // Source maps for JS output\n    resolveJsonModule: boolean;\n  };\n  include: string[];\n  exclude: string[];\n}\n```\n\nKey implementation details:\n1. **Sensible defaults**: The generated tsconfig.json must produce a configuration that allows `tsc` to compile the emitted .ts files without errors. Use the settings from PRD Task 1 spec: `target: ES2020`, `strict: true`, `esModuleInterop: true`. These are the baseline — the glass.config.json can override some settings.\n2. **Module system selection**: The glass.config.json may specify the target module system. Default to CommonJS for CLI projects and ESNext for library projects. The emitter should detect which is appropriate from the project context or allow configuration.\n3. **Include patterns**: Generate the `include` array to cover all emitted .ts files. Use `[\"**/*.ts\"]` or explicit file listing depending on project size. Exclude `node_modules/` and any test files.\n4. **Declaration generation**: Enable `declaration: true` and `declarationMap: true` so that the dist/ output can be consumed as a library with full type information. This is important for the `glass eject` use case (Task 24) where the emitted code becomes a standalone project.\n5. **Path consistency**: All paths in the tsconfig.json must be relative to the dist/ directory since that's where the file will live.\n6. **Atomic write**: Same temp file + rename pattern as the file emitter to prevent partial output.\n7. **Validation**: After generating, optionally validate the tsconfig by running a quick `tsc --noEmit` check if available (this can be deferred to the orchestrator in subtask 5).\n\nThe generated tsconfig.json should be minimal and standard — no exotic options, no Glass-specific configuration. A developer who runs `cd dist && tsc` should see zero errors.",
            "status": "pending",
            "testStrategy": "Test that generated tsconfig.json is valid JSON. Test that `target` is ES2020 and `strict` is true by default. Test that the `include` array covers all emitted files. Test with CommonJS module setting produces `module: 'commonjs'`. Test with ESNext module setting produces `module: 'esnext'`. Test that `declaration: true` is set for library output. Test that all paths are relative to the output directory. Test that the generated config works with `tsc --noEmit` when applied to a directory of simple .ts files. Test that glass.config.json overrides are applied correctly (e.g., different target). Test atomic write by verifying no partial file on write failure.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement package.json Generator for dist/ Output",
            "description": "Build the deployment-ready package.json generator that produces a valid npm package manifest for the dist/ directory, including correct entry points, external dependency listing collected from the dependency graph, and proper metadata from the Glass manifest.",
            "dependencies": [
              1
            ],
            "details": "Create src/compiler/emitter/package-json-generator.ts:\n\n```typescript\nexport interface PackageJsonOptions {\n  projectName: string;          // From manifest.glass\n  version: string;              // From manifest.glass\n  outputDir: string;            // dist/ directory path\n  dependencyGraph: DependencyGraph;  // From subtask 1 (for external deps)\n  entryPoint?: string;          // Main entry file (e.g., 'index.ts' or 'authenticate_user.ts')\n  projectConfig?: GlassConfig;  // From glass.config.json\n}\n\nexport class PackageJsonGenerator {\n  generate(options: PackageJsonOptions): Result<void, EmitterError>\n  private buildPackageJson(options: PackageJsonOptions): PackageJson\n  private collectExternalDependencies(graph: DependencyGraph): Record<string, string>\n  private determineEntryPoint(files: GlassFile[], config?: GlassConfig): string\n  private writePackageJson(pkg: PackageJson, outputDir: string): Result<void, EmitterError>\n}\n\ninterface PackageJson {\n  name: string;\n  version: string;\n  main: string;               // Entry point for CommonJS\n  module?: string;            // Entry point for ESM\n  types?: string;             // TypeScript declarations entry\n  scripts: {\n    build: string;            // 'tsc'\n    start?: string;\n  };\n  dependencies: Record<string, string>;    // External npm packages\n  devDependencies: Record<string, string>; // TypeScript, etc.\n  engines?: { node: string };\n}\n```\n\nKey implementation details:\n1. **Metadata from manifest**: Pull `name` and `version` from the Glass manifest (parsed in Task 6). The project name may need to be transformed to a valid npm package name (lowercase, no spaces, scoped if configured).\n2. **External dependency collection**: Use the DependencyGraph from subtask 1 to enumerate all external npm imports found across all GlassFile implementations. For each external package, determine the version: first check if the source project has a package.json with pinned versions; otherwise use `'*'` or `'latest'` and add an advisory.\n3. **Entry point determination**: Determine the `main` field. If the project has a root-level entry point (e.g., `index.glass`), use that. Otherwise, if glass.config.json specifies an entry, use that. As a fallback, use the first root-level GlassFile (one with `parent: null`). For library projects, also set `module` (ESM) and `types` (.d.ts) fields.\n4. **Scripts**: Include `\"build\": \"tsc\"` so `npm run build` works in the dist/ directory. Include `\"start\"` if the project appears to be an application (has a main entry point with executable code).\n5. **DevDependencies**: Include `typescript` and `@types/node` as devDependencies since the dist/ output needs them to compile further.\n6. **No Glass references**: The generated package.json must contain zero references to Glass, .glass files, or the Glass framework. It must look like a standard TypeScript npm project.\n7. **Atomic write**: Same pattern as other generators.\n8. **Validation**: The generated package.json must be valid JSON and pass `npm pack --dry-run` without errors.\n\nPer PRD Section 17.3, the dist/ directory should be deployable via `cd dist && npm install && wrangler deploy` (or equivalent). The package.json is what makes this possible.",
            "status": "pending",
            "testStrategy": "Test that generated package.json is valid JSON with required fields (name, version, main). Test that project name from manifest is correctly normalized to valid npm name. Test that external dependencies are collected from the dependency graph (e.g., if any GlassFile imports `bcrypt`, it appears in dependencies). Test that the version from manifest is used. Test that `scripts.build` is `'tsc'`. Test that TypeScript is in devDependencies. Test entry point determination: project with explicit entry in config uses that; project without falls back to root GlassFile. Test that no Glass-specific references appear in the output. Test the full Section 17 example: 6 auth files should produce a package.json with correct deps, entry point, and valid structure. Test that `npm pack --dry-run` would succeed on the generated package.json (validate structure).",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Build TypeScriptEmitter Orchestrator with Verification Gate and Atomic Output",
            "description": "Create the main TypeScriptEmitter class that orchestrates the full emission pipeline: enforces the verification-passed precondition, cleans the output directory, resolves dependencies, emits all .ts files, generates package.json and tsconfig.json, validates the output compiles with tsc, and implements atomic all-or-nothing output to guarantee no partial emission on failure.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create src/compiler/emitter/index.ts (main emitter module) with the `TypeScriptEmitter` class:\n\n```typescript\nexport interface EmitterOptions {\n  files: GlassFile[];\n  outputDir: string;                    // Typically 'dist/'\n  verificationResults: Map<string, VerificationResult>;\n  instrumentationPlans?: Map<string, InstrumentationPlan>;\n  manifest: Manifest;\n  projectConfig?: GlassConfig;\n  sourceMapEnabled?: boolean;           // Default: true\n  cleanOutput?: boolean;                // Default: true\n}\n\nexport class TypeScriptEmitter {\n  emit(options: EmitterOptions): Result<void, EmitterError>\n  private validatePreconditions(options: EmitterOptions): Result<void, EmitterError>\n  private cleanOutputDirectory(outputDir: string): void\n  private emitAllFiles(files: GlassFile[], graph: DependencyGraph, outputDir: string): Result<void, EmitterError>\n  private validateOutput(outputDir: string): Result<void, EmitterError>\n}\n\nexport interface EmitterError {\n  reason: 'VerificationNotPassed' | 'DependencyResolutionFailed' | 'FileEmissionFailed' | 'OutputValidationFailed' | 'WriteError';\n  message: string;\n  unitId?: string;              // Which file caused the error\n  details?: string[];           // Additional context\n}\n```\n\nOrchestration flow in `emit()`:\n1. **Precondition validation (`validatePreconditions`)**:\n   - Verify ALL files have corresponding VerificationResults in the map\n   - Verify ALL VerificationResults have `status: 'PROVEN'` (not FAILED)\n   - If any file is missing verification or has FAILED status, return `EmitterError { reason: 'VerificationNotPassed' }` immediately — the emitter REFUSES to emit unverified code. This is the core safety guarantee from PRD Section 11.1 step 6: \"Only if all verification passes.\"\n   - Validate the output directory path is reasonable (not root, not home, etc.)\n\n2. **Atomic output setup**:\n   - Create a temporary directory (e.g., `dist/.glass-emit-tmp/`) as the staging area\n   - ALL file writes go to the staging area first, NOT directly to the output directory\n   - This ensures no partial output: either everything succeeds and the staging directory is renamed to the output directory, or nothing is written\n\n3. **Clean output** (if `cleanOutput` is true):\n   - Remove existing contents of the output directory\n   - Preserve any user-created files if a `.glasskeep` marker exists (future consideration)\n\n4. **Dependency resolution**:\n   - Call `DependencyResolver.resolve(files)` from subtask 1\n   - If resolution fails (e.g., unresolvable import), return EmitterError and clean up staging\n\n5. **File emission**:\n   - Iterate through files in the dependency graph's emission order\n   - For each file, call `FileEmitter.emitFile()` from subtask 2 with the staging directory\n   - If any file emission fails, clean up the entire staging directory and return EmitterError\n   - Pass InstrumentationPlan for each file if available\n\n6. **Config generation**:\n   - Call `TsConfigGenerator.generate()` from subtask 3 — write to staging\n   - Call `PackageJsonGenerator.generate()` from subtask 4 — write to staging\n\n7. **Output validation (`validateOutput`)**:\n   - Run `tsc --noEmit` on the staging directory to verify the emitted code compiles\n   - If TypeScript compilation fails, the emission is REJECTED — clean up staging, return `EmitterError { reason: 'OutputValidationFailed' }` with the tsc error output\n   - This guarantees the contract: \"Generated code compiles with tsc\"\n\n8. **Atomic commit**:\n   - If all steps succeed, rename the staging directory to the actual output directory (atomic on most filesystems)\n   - If the rename fails (e.g., cross-device), fall back to copy + delete\n   - Delete the staging directory in all cases\n\n9. **Immutability guarantee**: The input GlassFile objects and verification results must NOT be modified by any emission step.\n\nExport `TypeScriptEmitter` as the public API. Also export a convenience function `emitTypeScript(options: EmitterOptions): Result<void, EmitterError>`. Re-export all emitter types (EmitterError, EmitterOptions, etc.) for consumer convenience.\n\nThe `glass compile` command (Task 13) will call this orchestrator after the verification step passes.",
            "status": "pending",
            "testStrategy": "Integration test: emit a set of well-formed, verified GlassFiles to a temp directory and verify: (a) all .ts files exist with correct content, (b) package.json exists and is valid, (c) tsconfig.json exists and is valid, (d) `tsc --noEmit` succeeds on the output. Test verification gate: provide GlassFiles where one has FAILED verification status — expect EmitterError with reason 'VerificationNotPassed' and verify zero files were written to output directory. Test missing verification: provide a GlassFile with no corresponding VerificationResult — expect same rejection. Test atomic output: simulate a failure during file emission (e.g., invalid implementation code) and verify the output directory is clean (no partial files). Test clean output: emit once, then emit again with cleanOutput=true and verify old files are removed. Test immutability: deep-clone inputs before and after emit, assert equality. Test with the full auth system example from PRD Section 17: 6 GlassFiles should produce 6 .ts files + package.json + tsconfig.json in dist/, and the output should be deployable via `cd dist && npm install`. Test source map generation is toggled by sourceMapEnabled flag. Test that the emitter refuses to write to dangerous paths (e.g., '/').",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-02-01T19:06:21.722Z"
      },
      {
        "id": "10",
        "title": "Implement CLI Framework and Command Router",
        "description": "Build the CLI framework using Commander.js and implement the command routing structure",
        "details": "Create src/cli/index.glass:\n\n1. Intent:\n   - Purpose: Provide command-line interface for all Glass operations\n   - Source: PRD Section 12\n   - Parent: null (top-level)\n\n2. Contract:\n   - Requires:\n     * Valid command and arguments\n     * Project context (when applicable)\n   - Guarantees on success:\n     * Routes to correct command handler\n     * Returns exit code 0\n     * Outputs user-friendly messages\n   - Guarantees on failure:\n     * Returns non-zero exit code\n     * Displays helpful error message\n   - Invariants:\n     * Commands are idempotent where applicable\n     * No destructive operations without confirmation\n\n3. Implementation:\n   ```typescript\n   #!/usr/bin/env node\n   import { Command } from 'commander'\n   \n   const program = new Command()\n   \n   program\n     .name('glass')\n     .description('Glass Framework - AI-authored, human-auditable, formally verified')\n     .version('0.1.0')\n   \n   // Register all commands from Section 12\n   program.command('init').action(initCommand)\n   program.command('generate').action(generateCommand)\n   program.command('verify').action(verifyCommand)\n   program.command('compile').action(compileCommand)\n   program.command('views').action(viewsCommand)\n   program.command('annotate').action(annotateCommand)\n   program.command('status').action(statusCommand)\n   program.command('tree').action(treeCommand)\n   program.command('trace').action(traceCommand)\n   program.command('diff').action(diffCommand)\n   program.command('eject').action(ejectCommand)\n   \n   program.parse()\n   ```\n\n4. Use chalk for colored terminal output\n5. Implement proper error handling and exit codes\n6. Support --help for all commands",
        "testStrategy": "Verify:\n- CLI runs as executable (#!/usr/bin/env node)\n- All commands from Section 12 are registered\n- --help displays usage information\n- --version displays correct version\n- Invalid commands show helpful error\n- Exit codes are correct (0 success, non-zero failure)\n- Can be installed globally with npm install -g\n- Can be run with npx",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-02-01T18:53:40.885Z"
      },
      {
        "id": "11",
        "title": "Implement 'glass init' Command",
        "description": "Build the init command that bootstraps a new Glass project with manifest, config, and directory structure",
        "details": "Create src/cli/commands/init.glass:\n\n1. Intent:\n   - Purpose: Initialize a new Glass project with proper structure and configuration\n   - Source: PRD Section 12 'glass init'\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Project name argument\n     * Optional --language flag (typescript | rust, default: typescript)\n     * Target directory does not exist or is empty\n   - Guarantees on success:\n     * Creates project directory\n     * Generates manifest.glass\n     * Generates glass.config.json\n     * Creates all required directories (Section 16)\n     * Installs if --install flag provided\n   - Guarantees on failure:\n     * No partial project created\n     * Returns error if directory exists and not empty\n\n3. Implementation:\n   ```typescript\n   export async function initCommand(projectName: string, options: InitOptions) {\n     // 1. Validate project name\n     // 2. Check target directory\n     // 3. Create directory structure (Section 16)\n     // 4. Generate manifest.glass template\n     // 5. Generate glass.config.json\n     // 6. Create placeholder README.md\n     // 7. Initialize git repo (optional)\n     // 8. Run npm init if --install\n     // 9. Display success message with next steps\n   }\n   \n   interface InitOptions {\n     language: 'typescript' | 'rust'\n     install?: boolean\n     git?: boolean\n   }\n   ```\n\n4. Templates for manifest.glass and glass.config.json\n5. Success message with next steps",
        "testStrategy": "Verify:\n- Creates all directories from Section 16\n- Generates valid manifest.glass\n- Generates valid glass.config.json\n- Language adapter selected correctly\n- Prevents overwriting existing projects\n- Optional flags work correctly\n- Success message is helpful\n- Can initialize both TypeScript and Rust projects",
        "priority": "high",
        "dependencies": [
          "6",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "12",
        "title": "Implement 'glass verify' Command",
        "description": "Build the verify command that runs contract verification and outputs verification checklists",
        "details": "Create src/cli/commands/verify.glass:\n\n1. Intent:\n   - Purpose: Run verification pipeline and report contract satisfaction status\n   - Source: PRD Section 12 'glass verify'\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Valid Glass project (manifest.glass exists)\n     * At least one .glass file in src/\n   - Guarantees on success:\n     * Returns VerificationResult for all units\n     * Outputs verification checklists to .generated/\n     * Returns exit code 0 if all verified\n     * Returns exit code 1 if any verification fails\n   - Guarantees on failure:\n     * Displays which units failed\n     * Displays which assertions failed\n     * Returns non-zero exit code\n\n3. Implementation:\n   ```typescript\n   export async function verifyCommand(options: VerifyOptions) {\n     // 1. Load manifest\n     // 2. Discover all .glass files in src/\n     // 3. Parse each file\n     // 4. Link intent tree\n     // 5. Run verifier on each file\n     // 6. Generate verification checklists\n     // 7. Display summary dashboard in terminal\n     // 8. Exit with appropriate code\n   }\n   \n   // Terminal output format:\n   // ✓ auth.authenticate_user: PROVEN (15/15 assertions)\n   // ✓ auth.validate_credentials: PROVEN (8/8 assertions)\n   // ⚠ auth.rate_limit_login: PROVEN with 1 advisory\n   // ✗ orders.refund_order: FAILED (2/10 assertions failed)\n   ```\n\n4. Colored output (green ✓, yellow ⚠, red ✗)\n5. Summary statistics (total units, passed, failed, advisories)\n6. Option to show only failures (--failures-only)",
        "testStrategy": "Verify:\n- Discovers all .glass files correctly\n- Runs verification on each file\n- Generates verification checklists\n- Terminal output is clear and scannable\n- Exit codes are correct (0 pass, 1 fail)\n- --failures-only works\n- Works with auth example from Section 17\n- Performance is reasonable for large projects",
        "priority": "high",
        "dependencies": [
          "7",
          "10"
        ],
        "status": "in-progress",
        "subtasks": [],
        "updatedAt": "2026-02-01T19:11:08.843Z"
      },
      {
        "id": "13",
        "title": "Implement 'glass compile' Command",
        "description": "Build the compile command that runs full compilation pipeline: verify + emit code",
        "details": "Create src/cli/commands/compile.glass:\n\n1. Intent:\n   - Purpose: Run full Glass compilation pipeline and emit deployable code\n   - Source: PRD Section 12 'glass compile'\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Valid Glass project\n     * At least one .glass file\n   - Guarantees on success:\n     * All verifications pass\n     * Clean target-language code emitted to dist/\n     * Views generated to .generated/\n     * Exit code 0\n   - Guarantees on failure:\n     * No code emitted if verification fails\n     * Clear error message\n     * Exit code 1\n\n3. Implementation:\n   ```typescript\n   export async function compileCommand(options: CompileOptions) {\n     // Pipeline from Section 11.1:\n     // 1. Parse all .glass files\n     // 2. Link intent tree\n     // 3. Verify completeness\n     // 4. Verify contracts\n     // 5. Generate views\n     // 6. Emit code (ONLY if all verification passes)\n     \n     // Display progress:\n     // [1/6] Parsing .glass files... ✓\n     // [2/6] Linking intent tree... ✓\n     // [3/6] Verifying completeness... ✓\n     // [4/6] Verifying contracts... ✓ (1 advisory)\n     // [5/6] Generating views... ✓\n     // [6/6] Emitting TypeScript... ✓\n     //\n     // Compilation successful!\n     // Output: dist/\n   }\n   ```\n\n4. Option to skip verification (--no-verify) for development\n5. Option to clean dist/ before emitting (--clean)\n6. Progress indicator for large projects",
        "testStrategy": "Verify:\n- Full pipeline executes in correct order (Section 11.1)\n- Compilation stops if verification fails\n- Code only emitted if all checks pass\n- dist/ contains valid TypeScript\n- .generated/ contains all views\n- Progress output is clear\n- Works with auth example from Section 17\n- Can compile into deployable package",
        "priority": "high",
        "dependencies": [
          "9",
          "12"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "14",
        "title": "Implement 'glass views' Command",
        "description": "Build the views command that generates all human-readable outlines and dashboards without compilation",
        "details": "Create src/cli/commands/views.glass:\n\n1. Intent:\n   - Purpose: Generate human-readable views without running full compilation\n   - Source: PRD Section 12 'glass views'\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Valid Glass project\n     * At least one .glass file\n   - Guarantees on success:\n     * All views generated to .generated/\n     * Exit code 0\n   - Guarantees on failure:\n     * Partial views may exist\n     * Error message indicates which view failed\n\n3. Implementation:\n   ```typescript\n   export async function viewsCommand(options: ViewsOptions) {\n     // 1. Parse all .glass files\n     // 2. Link intent tree\n     // 3. Run verifier (for verification checklists)\n     // 4. Generate all views\n     // 5. Display summary of generated files\n   }\n   \n   // Options:\n   // --view <type>: Generate specific view only\n   //   Types: business, security, verification, intent, contract\n   // --unit <id>: Generate views for specific unit only\n   ```",
        "testStrategy": "Verify:\n- Generates all view types from Section 10\n- --view flag filters correctly\n- --unit flag filters correctly\n- Views are synchronized with .glass files\n- Generated files match PRD examples\n- Success message lists generated files",
        "priority": "medium",
        "dependencies": [
          "8",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "15",
        "title": "Implement 'glass status' Command",
        "description": "Build the status command that displays verification status dashboard for all units",
        "details": "Create src/cli/commands/status.glass:\n\n1. Intent:\n   - Purpose: Display current verification status of all units\n   - Source: PRD Section 12 'glass status'\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Valid Glass project\n   - Guarantees on success:\n     * Displays summary dashboard\n     * Shows per-unit status\n     * Highlights advisories and failures\n     * Exit code 0\n\n3. Implementation:\n   ```typescript\n   export async function statusCommand(options: StatusOptions) {\n     // 1. Load project\n     // 2. Parse and verify all units\n     // 3. Generate status dashboard (similar to Section 10.3)\n     \n     // Terminal output:\n     // GLASS PROJECT STATUS\n     // \n     // Units: 6 total\n     //   ✓ 5 verified\n     //   ⚠ 1 with advisories\n     //   ✗ 0 failed\n     //\n     // Pending Approvals: 2\n     //   - auth.sanitize_input (AI-generated, security)\n     //   - auth.rate_limit_login (AI-generated, security)\n     //\n     // Per-Unit Status:\n     //   ✓ auth.authenticate_user (PROVEN)\n     //   ✓ auth.validate_credentials (PROVEN)\n     //   ⚠ auth.rate_limit_login (PROVEN, 1 advisory)\n     //   ...\n   }\n   ```",
        "testStrategy": "Verify:\n- Dashboard shows accurate statistics\n- Per-unit status is correct\n- Advisories are highlighted\n- Pending approvals are listed\n- Output is scannable and clear\n- Works with large projects (100+ units)",
        "priority": "medium",
        "dependencies": [
          "7",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "16",
        "title": "Implement 'glass tree' Command",
        "description": "Build the tree command that displays the full intent hierarchy in a tree structure",
        "details": "Create src/cli/commands/tree.glass:\n\n1. Intent:\n   - Purpose: Display the full intent tree hierarchy\n   - Source: PRD Section 12 'glass tree'\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Valid Glass project\n   - Guarantees on success:\n     * Displays tree with proper indentation\n     * Shows approval status\n     * Shows source for each intent\n     * Exit code 0\n\n3. Implementation:\n   ```typescript\n   export async function treeCommand(options: TreeOptions) {\n     // 1. Load and link intent tree\n     // 2. Render as ASCII tree\n     \n     // Example output:\n     // AuthSystem (PRD, approved)\n     // ├── AuthenticateUser (PRD, approved)\n     // │   ├── ValidateCredentials (conversation, approved)\n     // │   ├── ManageSession (conversation, approved)\n     // │   ├── SanitizeInput (AI-generated, auto-approved)\n     // │   ├── RateLimitLogin (AI-generated, pending)\n     // │   └── LogAuthAttempt (AI-generated, auto-approved)\n     // └── ...\n   }\n   \n   // Options:\n   // --depth <n>: Limit tree depth\n   // --status <status>: Filter by approval status\n   ```\n\n4. Use tree characters (├──, └──, │) for visual hierarchy",
        "testStrategy": "Verify:\n- Tree structure is correct\n- Indentation represents hierarchy\n- Approval status shown for each intent\n- Source shown for each intent\n- --depth flag works\n- --status filter works\n- Large trees are readable",
        "priority": "medium",
        "dependencies": [
          "5",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "17",
        "title": "Implement 'glass trace' Command",
        "description": "Build the trace command that shows the full provenance chain from business goal to implementation",
        "details": "Create src/cli/commands/trace.glass:\n\n1. Intent:\n   - Purpose: Show full provenance chain for a unit\n   - Source: PRD Section 12 'glass trace'\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Valid Glass project\n     * Unit ID argument\n   - Guarantees on success:\n     * Displays full ancestry chain\n     * Shows origin for each level\n     * Shows contracts at each level\n     * Exit code 0\n   - Guarantees on failure:\n     * Error if unit ID not found\n\n3. Implementation:\n   ```typescript\n   export async function traceCommand(unitId: string, options: TraceOptions) {\n     // 1. Load intent tree and manifest\n     // 2. Find unit\n     // 3. Walk up parent chain to root\n     // 4. Display chain with details\n     \n     // Example output (from Section 7.3):\n     // Provenance: auth.sanitize_input\n     //\n     // Business Goal: \"Users can manage their accounts\"\n     //   Source: PRD section 3.1\n     //   ↓\n     // Intent: \"Users can view order history\"\n     //   Source: Conversation #12, user request\n     //   Contract: RetrieveOrders\n     //   ↓\n     // Implementation: retrieve_orders.glass\n     //   ↓\n     // Sub-intent: \"Sanitize order query input\"\n     //   Source: AI-generated (security)\n     //   Auto-approved under security policy\n     //   Contract: SanitizeInput\n     //   Implementation: sanitize_input.glass\n   }\n   ```",
        "testStrategy": "Verify:\n- Trace walks full ancestry chain\n- All origins are displayed\n- Contracts are shown at each level\n- Matches example from Section 7.3\n- Error for invalid unit ID\n- Works with deeply nested intents",
        "priority": "medium",
        "dependencies": [
          "5",
          "6",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "18",
        "title": "Implement Annotation System",
        "description": "Build the annotation system that allows humans to attach notes to generated outlines",
        "details": "Create src/cli/commands/annotate.glass and src/compiler/annotations.glass:\n\n1. Intent:\n   - Purpose: Allow humans to attach notes to generated outlines for AI to act on\n   - Source: PRD Section 8.4\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Valid Glass project\n     * Unit ID\n     * Line number or section identifier\n     * Annotation text\n   - Guarantees on success:\n     * Annotation stored in .annotations/\n     * Annotation appears in generated views\n     * AI can read and act on annotations\n   - Guarantees on failure:\n     * Error if unit or line doesn't exist\n\n3. Implementation:\n   ```typescript\n   // CLI command:\n   export async function annotateCommand(\n     unitId: string,\n     target: string, // line number or section\n     note: string\n   ) {\n     // 1. Validate unit exists\n     // 2. Create annotation object\n     // 3. Store in .annotations/<unitId>.annotations.json\n     // 4. Regenerate views to show annotation\n   }\n   \n   // Annotation storage:\n   interface Annotation {\n     id: string\n     unitId: string\n     target: string // 'contract.guarantees.success.2' or 'line:15'\n     note: string\n     author: string\n     timestamp: string\n     resolved: boolean\n   }\n   \n   // View generator integration:\n   // When generating contract outline, inject annotations:\n   // Guarantees on success:\n   //   ✓ Session linked to verified user\n   //   ✓ Session expires after configured duration\n   //     📝 Human note: \"duration should be 24 hours for regular\n   //        users, 1 hour for admin users. AI — please implement\n   //        this distinction.\"\n   ```\n\n4. Support for annotation resolution (mark as done)\n5. List all annotations for a unit\n6. List all unresolved annotations across project",
        "testStrategy": "Verify:\n- Annotations are stored correctly\n- Annotations appear in generated views\n- Annotation format matches Section 8.4\n- Can annotate different target types\n- Can list annotations per unit\n- Can list all unresolved annotations\n- Annotations survive view regeneration",
        "priority": "medium",
        "dependencies": [
          "8",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "19",
        "title": "Implement MCP Server",
        "description": "Build the Model Context Protocol server that exposes Glass commands as tools for AI assistants",
        "details": "Create packages/mcp-server/ (separate package):\n\n1. Intent:\n   - Purpose: Expose Glass CLI as MCP tools for AI assistants\n   - Source: PRD Section 14.2\n   - Parent: distribution\n\n2. Contract:\n   - Requires:\n     * @glass-framework/cli installed\n     * Valid MCP server configuration\n     * Project root path\n   - Guarantees on success:\n     * Exposes all tools from Section 14.2\n     * Tools call corresponding CLI commands\n     * Returns structured results\n     * Works with any MCP-compatible client\n\n3. Implementation:\n   ```typescript\n   // packages/mcp-server/src/index.ts\n   import { Server } from '@modelcontextprotocol/sdk/server/index.js'\n   import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'\n   \n   const server = new Server({\n     name: 'glass-mcp-server',\n     version: '0.1.0'\n   }, {\n     capabilities: {\n       tools: {}\n     }\n   })\n   \n   // Register all tools from Section 14.2:\n   server.setRequestHandler('tools/list', async () => ({\n     tools: [\n       { name: 'glass_init', description: 'Initialize a Glass project', inputSchema: {...} },\n       { name: 'glass_generate', description: 'Generate .glass files', inputSchema: {...} },\n       { name: 'glass_verify', description: 'Run verification', inputSchema: {...} },\n       { name: 'glass_compile', description: 'Full compilation', inputSchema: {...} },\n       { name: 'glass_views', description: 'Generate views', inputSchema: {...} },\n       { name: 'glass_status', description: 'Show status', inputSchema: {...} },\n       { name: 'glass_annotate', description: 'Add annotation', inputSchema: {...} },\n       { name: 'glass_tree', description: 'Show intent tree', inputSchema: {...} },\n       { name: 'glass_trace', description: 'Show provenance', inputSchema: {...} }\n     ]\n   }))\n   \n   server.setRequestHandler('tools/call', async (request) => {\n     // Route to CLI commands and return structured results\n   })\n   ```\n\n4. Wrap CLI commands and parse output\n5. Return structured JSON responses\n6. Handle errors gracefully\n7. Support project context parameter",
        "testStrategy": "Verify:\n- MCP server starts correctly\n- All tools are exposed\n- Tools call CLI commands correctly\n- Structured results are returned\n- Works with Claude Code's MCP client\n- Error handling is robust\n- Can be configured in .mcp.json\n- Integration test with real MCP client",
        "priority": "high",
        "dependencies": [
          "11",
          "12",
          "13",
          "14",
          "15",
          "16",
          "17",
          "18"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up MCP Server Package Scaffold with SDK Integration and Stdio Transport",
            "description": "Create the packages/mcp-server/ directory as a separate npm package (@glass-framework/mcp-server) with the MCP SDK dependency, TypeScript configuration, package.json, and the core server initialization using StdioServerTransport. This establishes the foundation that all other subtasks build on.",
            "dependencies": [],
            "details": "Create the packages/mcp-server/ directory structure and initialize as a standalone npm package:\n\n1. **Package initialization** — Create packages/mcp-server/package.json:\n   - name: `@glass-framework/mcp-server`\n   - version: `0.1.0`\n   - main: `dist/index.js`\n   - bin: `{ \"glass-mcp-server\": \"./dist/index.js\" }` (matching PRD Section 14.2's `\"command\": \"glass-mcp-server\"`)\n   - dependencies: `@modelcontextprotocol/sdk` (latest), `@glass-framework/cli` (workspace reference)\n   - devDependencies: `typescript`, `@types/node`, `jest`, `ts-jest`\n   - scripts: `build`, `start`, `test`\n\n2. **TypeScript configuration** — Create packages/mcp-server/tsconfig.json:\n   - strict mode enabled\n   - target: ES2020, module: Node16/NodeNext for ESM compatibility\n   - outDir: dist/\n   - rootDir: src/\n\n3. **Server entrypoint** — Create packages/mcp-server/src/index.ts:\n   ```typescript\n   #!/usr/bin/env node\n   import { Server } from '@modelcontextprotocol/sdk/server/index.js'\n   import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'\n   import { CallToolRequestSchema, ListToolsRequestSchema } from '@modelcontextprotocol/sdk/types.js'\n   \n   const server = new Server(\n     { name: 'glass-mcp-server', version: '0.1.0' },\n     { capabilities: { tools: {} } }\n   )\n   \n   // Parse --project CLI arg for project root context\n   const args = process.argv.slice(2)\n   let projectRoot = process.cwd()\n   const projectIdx = args.indexOf('--project')\n   if (projectIdx !== -1 && args[projectIdx + 1]) {\n     projectRoot = path.resolve(args[projectIdx + 1])\n   }\n   \n   // Tool handlers will be registered here (subtasks 2, 3)\n   \n   async function main() {\n     const transport = new StdioServerTransport()\n     await server.connect(transport)\n   }\n   main().catch(console.error)\n   ```\n\n4. **Project context module** — Create packages/mcp-server/src/context.ts to manage project root path, validate that a Glass project exists (check for manifest.glass), and load glass.config.json if present. Export a `ProjectContext` class that all tool handlers receive.\n\n5. **Directory structure**:\n   ```\n   packages/mcp-server/\n   ├── package.json\n   ├── tsconfig.json\n   └── src/\n       ├── index.ts          # Server entrypoint + stdio transport\n       ├── context.ts         # Project context management\n       ├── tools/             # Tool definitions (subtask 2)\n       └── handlers/          # Tool handlers (subtask 3)\n   ```\n\nThis must produce a package that can be configured in .mcp.json as shown in PRD Section 14.2:\n```json\n{ \"mcpServers\": { \"glass\": { \"command\": \"glass-mcp-server\", \"args\": [\"--project\", \"./my-project\"] } } }\n```",
            "status": "pending",
            "testStrategy": "Verify the package compiles with tsc without errors. Verify the bin entry creates a valid executable. Test that --project argument parsing correctly resolves absolute and relative paths. Test that ProjectContext validates a Glass project directory (returns error for non-Glass directories). Test that the server starts without errors and connects to stdio transport (mock transport). Verify package.json has correct dependency on @modelcontextprotocol/sdk. Test that the server can be configured in .mcp.json format matching PRD Section 14.2.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Define JSON Schema Tool Definitions for All 9 MCP Tools",
            "description": "Create complete MCP tool definitions with JSON Schema inputSchema for all 9 tools from PRD Section 14.2: glass_init, glass_generate, glass_verify, glass_compile, glass_views, glass_status, glass_annotate, glass_tree, glass_trace. Register them in the tools/list handler.",
            "dependencies": [
              1
            ],
            "details": "Create packages/mcp-server/src/tools/definitions.ts containing all 9 tool schemas, then register the ListToolsRequestSchema handler in the server.\n\nEach tool definition must follow the MCP SDK's Tool interface with `name`, `description`, and `inputSchema` (JSON Schema). Derive input schemas from the CLI command interfaces in Tasks 11–18:\n\n```typescript\nexport const GLASS_TOOLS = [\n  {\n    name: 'glass_init',\n    description: 'Initialize a new Glass project with manifest, config, and directory structure',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        projectName: { type: 'string', description: 'Name of the project to initialize' },\n        language: { type: 'string', enum: ['typescript', 'rust'], default: 'typescript', description: 'Target language' },\n        install: { type: 'boolean', default: false, description: 'Run npm install after initialization' },\n        git: { type: 'boolean', default: true, description: 'Initialize git repository' }\n      },\n      required: ['projectName']\n    }\n  },\n  {\n    name: 'glass_generate',\n    description: 'Generate .glass files from conversation context and manifest',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        context: { type: 'string', description: 'Conversation context or requirements for generation' },\n        parentIntent: { type: 'string', description: 'Parent intent ID for generated units' },\n        unitId: { type: 'string', description: 'Specific unit ID to generate' }\n      },\n      required: ['context']\n    }\n  },\n  {\n    name: 'glass_verify',\n    description: 'Run contract verification pipeline and return verification checklist results',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        unit: { type: 'string', description: 'Specific unit ID to verify (omit for all)' },\n        failuresOnly: { type: 'boolean', default: false, description: 'Show only failures' }\n      }\n    }\n  },\n  {\n    name: 'glass_compile',\n    description: 'Run full Glass compilation pipeline: verify + emit target-language code',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        noVerify: { type: 'boolean', default: false, description: 'Skip verification step' },\n        clean: { type: 'boolean', default: false, description: 'Clean dist/ before emitting' }\n      }\n    }\n  },\n  {\n    name: 'glass_views',\n    description: 'Generate human-readable outlines, checklists, and dashboards',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        view: { type: 'string', enum: ['business', 'security', 'verification', 'intent', 'contract'], description: 'Specific view type to generate' },\n        unit: { type: 'string', description: 'Generate views for specific unit ID only' }\n      }\n    }\n  },\n  {\n    name: 'glass_status',\n    description: 'Return current verification status of all units as a summary dashboard',\n    inputSchema: { type: 'object', properties: {} }\n  },\n  {\n    name: 'glass_annotate',\n    description: 'Add a human annotation to a specific line or section in a generated outline',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        unitId: { type: 'string', description: 'Unit ID to annotate' },\n        target: { type: 'string', description: 'Line number or section identifier (e.g., \"line:15\" or \"contract.guarantees.success.2\")' },\n        note: { type: 'string', description: 'Annotation text' }\n      },\n      required: ['unitId', 'target', 'note']\n    }\n  },\n  {\n    name: 'glass_tree',\n    description: 'Display the full intent hierarchy tree with approval status and sources',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        depth: { type: 'number', description: 'Maximum tree depth to display' },\n        status: { type: 'string', enum: ['approved', 'pending', 'auto-approved'], description: 'Filter by approval status' }\n      }\n    }\n  },\n  {\n    name: 'glass_trace',\n    description: 'Show the full provenance chain for a unit: from business goal to implementation',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        unitId: { type: 'string', description: 'Unit ID to trace provenance for' }\n      },\n      required: ['unitId']\n    }\n  }\n]\n```\n\nRegister in the server:\n```typescript\nserver.setRequestHandler(ListToolsRequestSchema, async () => ({ tools: GLASS_TOOLS }))\n```\n\nAll schemas must be valid JSON Schema draft-07. Every property needs a description since AI assistants use these to understand how to call the tools.",
            "status": "pending",
            "testStrategy": "Validate all 9 tool schemas are valid JSON Schema (use a JSON Schema validator library). Verify required fields are correctly specified for each tool (glass_init needs projectName, glass_annotate needs unitId/target/note, glass_trace needs unitId). Test that the tools/list handler returns all 9 tools with correct names, descriptions, and schemas. Verify enum values match the CLI command options (language: typescript/rust, view types, approval statuses). Test that schemas with no required properties accept empty objects. Verify all property descriptions are present and meaningful for AI consumption.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Implement Tool Router, CLI Command Wrappers, and Structured JSON Response Formatting",
            "description": "Build the tools/call request handler that dispatches incoming tool calls to the correct CLI command wrapper, executes Glass CLI commands programmatically (importing from @glass-framework/cli), and formats results as structured JSON responses conforming to MCP's content format.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create two modules:\n\n**1. CLI Command Wrappers** — packages/mcp-server/src/handlers/cli-wrappers.ts\n\nWrap each of the 9 CLI commands from Tasks 11–18 to be callable programmatically (not via subprocess). Import the CLI command functions directly from @glass-framework/cli:\n\n```typescript\nimport { initCommand } from '@glass-framework/cli/commands/init'\nimport { verifyCommand } from '@glass-framework/cli/commands/verify'\n// ... etc for all 9 commands\n\nexport interface CommandResult {\n  success: boolean\n  data: Record<string, unknown>    // Structured result data\n  output: string                   // Human-readable summary\n  warnings?: string[]              // Any advisories/warnings\n}\n\nexport async function executeGlassInit(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\nexport async function executeGlassGenerate(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\nexport async function executeGlassVerify(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\nexport async function executeGlassCompile(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\nexport async function executeGlassViews(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\nexport async function executeGlassStatus(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\nexport async function executeGlassAnnotate(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\nexport async function executeGlassTree(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\nexport async function executeGlassTrace(args: Record<string, unknown>, ctx: ProjectContext): Promise<CommandResult>\n```\n\nEach wrapper:\n- Validates input args against expected types\n- Sets the working directory to ProjectContext.projectRoot\n- Calls the corresponding CLI command function\n- Captures output (redirect console output to string buffer)\n- Returns structured CommandResult with both data and human-readable output\n\n**2. Tool Router/Dispatcher** — packages/mcp-server/src/handlers/router.ts\n\nRegister the CallToolRequestSchema handler that routes to the correct wrapper:\n\n```typescript\nimport { CallToolRequestSchema } from '@modelcontextprotocol/sdk/types.js'\n\nserver.setRequestHandler(CallToolRequestSchema, async (request) => {\n  const { name, arguments: args } = request.params\n  const ctx = getProjectContext()\n  \n  let result: CommandResult\n  switch (name) {\n    case 'glass_init':     result = await executeGlassInit(args, ctx); break\n    case 'glass_generate': result = await executeGlassGenerate(args, ctx); break\n    // ... all 9 tools\n    default:\n      return { content: [{ type: 'text', text: `Unknown tool: ${name}` }], isError: true }\n  }\n  \n  // Format as MCP response\n  return {\n    content: [{\n      type: 'text',\n      text: JSON.stringify({\n        success: result.success,\n        data: result.data,\n        summary: result.output,\n        warnings: result.warnings\n      }, null, 2)\n    }],\n    isError: !result.success\n  }\n})\n```\n\n**3. Response Formatting** — Ensure all responses follow a consistent JSON structure within the MCP `content` array. The `data` field contains tool-specific structured data (e.g., verification results as arrays, tree as nested objects, trace as chain arrays). The `summary` field contains a human-readable text version. This dual format allows AI assistants to programmatically parse `data` while displaying `summary` to users.",
            "status": "pending",
            "testStrategy": "Test the router dispatches each of the 9 tool names to the correct wrapper function (mock the wrappers). Test that unknown tool names return isError: true with helpful message. Test each CLI wrapper with valid arguments (mock the underlying CLI commands). Test that CommandResult structure is consistent across all wrappers. Test that MCP response content is valid JSON with success/data/summary/warnings fields. Test that args validation catches type mismatches (e.g., passing number where string expected). Test that projectRoot context is correctly passed through to each command. Integration test: mock the full flow from CallToolRequestSchema through router to wrapper and verify response shape.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Implement Error Handling with MCP Error Codes and Graceful Failure Responses",
            "description": "Build comprehensive error handling for the MCP server covering: input validation errors, CLI command failures, missing project context, network/transport errors, and MCP protocol-level error codes. Ensure all error responses are structured and informative for AI assistant consumers.",
            "dependencies": [
              3
            ],
            "details": "Create packages/mcp-server/src/errors.ts and integrate error handling throughout the server:\n\n**1. Error Classification and MCP Error Codes**:\n\n```typescript\nimport { McpError, ErrorCode } from '@modelcontextprotocol/sdk/types.js'\n\n// Map Glass-specific errors to MCP error codes\nexport enum GlassErrorCode {\n  PROJECT_NOT_FOUND = 'PROJECT_NOT_FOUND',\n  INVALID_ARGUMENTS = 'INVALID_ARGUMENTS',\n  COMMAND_FAILED = 'COMMAND_FAILED',\n  VERIFICATION_FAILED = 'VERIFICATION_FAILED',\n  UNIT_NOT_FOUND = 'UNIT_NOT_FOUND',\n  MANIFEST_ERROR = 'MANIFEST_ERROR',\n  PARSE_ERROR = 'PARSE_ERROR'\n}\n\nexport function toMcpError(glassError: GlassErrorCode, message: string, details?: unknown): McpError {\n  // Map Glass errors to MCP ErrorCode:\n  // INVALID_ARGUMENTS -> ErrorCode.InvalidParams\n  // COMMAND_FAILED -> ErrorCode.InternalError\n  // UNIT_NOT_FOUND -> ErrorCode.InvalidParams\n  // PROJECT_NOT_FOUND -> ErrorCode.InvalidParams\n  return new McpError(mapToMcpCode(glassError), message, details)\n}\n```\n\n**2. Input Validation Layer**:\n\nCreate packages/mcp-server/src/handlers/validator.ts:\n```typescript\nexport function validateToolArgs(toolName: string, args: Record<string, unknown>): void {\n  // Validate required fields exist (from tool schemas in subtask 2)\n  // Validate types match schema expectations\n  // Validate enum values are valid\n  // Throw McpError with ErrorCode.InvalidParams on failure\n}\n```\n\n**3. Command Execution Error Wrapping**:\n\nWrap all CLI command executions in try/catch in the router:\n```typescript\ntry {\n  result = await executeGlassVerify(args, ctx)\n} catch (error) {\n  if (error instanceof GlassParseError) {\n    throw toMcpError(GlassErrorCode.PARSE_ERROR, `Failed to parse .glass file: ${error.message}`, { file: error.filePath, line: error.line })\n  }\n  if (error instanceof GlassVerificationError) {\n    // Return as structured failure (not thrown), since verification failures are expected\n    return {\n      content: [{ type: 'text', text: JSON.stringify({\n        success: false,\n        error: GlassErrorCode.VERIFICATION_FAILED,\n        failedAssertions: error.assertions,\n        summary: error.message\n      }, null, 2) }],\n      isError: false  // verification failure is a valid result, not a server error\n    }\n  }\n  // Unexpected errors\n  throw toMcpError(GlassErrorCode.COMMAND_FAILED, error.message)\n}\n```\n\n**4. Distinguish between server errors and command results**:\n- MCP `isError: true` — reserved for actual server/protocol errors (tool not found, invalid params, internal crash)\n- MCP `isError: false` with `success: false` in the JSON body — for expected failures like verification failures, unit not found, etc. This allows AI assistants to inspect the failure details and take corrective action.\n\n**5. Project context validation**:\n- Before executing any tool (except glass_init), validate that projectRoot points to a valid Glass project (manifest.glass exists)\n- Return clear error message if project not initialized, suggesting the AI call glass_init first\n\n**6. Graceful shutdown**:\n- Handle SIGINT/SIGTERM for clean server shutdown\n- Handle stdio stream errors (broken pipe, EOF) gracefully\n- Log errors to stderr (not stdout, since stdout is the MCP transport)",
            "status": "pending",
            "testStrategy": "Test that invalid arguments (missing required fields, wrong types, invalid enum values) produce McpError with ErrorCode.InvalidParams. Test that CLI parse errors produce structured error with file path and line number. Test that verification failures return isError: false with structured failure details (not thrown as server errors). Test that unknown tool names produce proper MCP error. Test that calling tools without a valid Glass project (no manifest.glass) returns clear 'project not found' error suggesting glass_init. Test that unexpected/unhandled errors are caught and wrapped in McpError with InternalError code. Test SIGINT handling triggers clean shutdown. Test that all errors are logged to stderr, not stdout. Test error response JSON structure is consistent across all error types.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Integration Testing with MCP Client and End-to-End Server Validation",
            "description": "Build integration tests that verify the complete MCP server works end-to-end: server startup, tool listing, tool execution for all 9 tools, error scenarios, and compatibility with MCP client configuration in .mcp.json. Include tests simulating Claude Code's MCP client behavior.",
            "dependencies": [
              4
            ],
            "details": "Create packages/mcp-server/tests/ with comprehensive integration tests:\n\n**1. Test Infrastructure** — packages/mcp-server/tests/setup.ts:\n\n```typescript\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js'\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js'\n\n// Helper to spawn the MCP server as a child process and connect via stdio\nexport async function createTestClient(projectRoot: string): Promise<Client> {\n  const transport = new StdioClientTransport({\n    command: 'node',\n    args: ['dist/index.js', '--project', projectRoot]\n  })\n  const client = new Client({ name: 'test-client', version: '1.0.0' }, { capabilities: {} })\n  await client.connect(transport)\n  return client\n}\n\n// Helper to create a temporary Glass project directory for testing\nexport async function createTempGlassProject(): Promise<string>\nexport async function cleanupTempProject(path: string): Promise<void>\n```\n\n**2. Server Lifecycle Tests** — packages/mcp-server/tests/server.test.ts:\n- Test server starts and responds to initialize handshake\n- Test server lists capabilities correctly (tools: {})\n- Test server shuts down cleanly on disconnect\n- Test server handles --project argument correctly\n- Test server handles missing --project gracefully (defaults to cwd)\n\n**3. Tool Listing Tests** — packages/mcp-server/tests/tools-list.test.ts:\n- Test tools/list returns exactly 9 tools\n- Test each tool has name, description, and inputSchema\n- Test tool names match PRD Section 14.2 (glass_init through glass_trace)\n- Test input schemas are valid JSON Schema\n\n**4. Tool Execution Tests** — packages/mcp-server/tests/tools-call.test.ts:\n\nFor each of the 9 tools, test with valid arguments and verify:\n- Response contains `content` array with at least one text entry\n- Response JSON has `success`, `data`, and `summary` fields\n- Tool-specific data structure is correct:\n  - glass_init: returns project path and created file list\n  - glass_verify: returns verification results with per-unit status\n  - glass_compile: returns compilation status and output paths\n  - glass_views: returns list of generated view files\n  - glass_status: returns unit count, passed/failed/advisory counts\n  - glass_annotate: returns annotation ID and confirmation\n  - glass_tree: returns tree structure as nested object\n  - glass_trace: returns provenance chain as ordered array\n\n**5. Error Scenario Tests** — packages/mcp-server/tests/errors.test.ts:\n- Test calling tool with missing required arguments\n- Test calling tool with invalid argument types\n- Test calling non-existent tool name\n- Test calling tools on non-Glass project directory\n- Test glass_trace with non-existent unit ID\n- Test glass_annotate with invalid target format\n\n**6. .mcp.json Configuration Test** — packages/mcp-server/tests/config.test.ts:\n- Verify the server can be configured with the exact .mcp.json format from PRD Section 14.2\n- Test that the configuration format matches what Claude Code, Claude Desktop, and other MCP clients expect\n\n**7. Test with mock CLI** — Since CLI commands (Tasks 11–18) may not be implemented yet, create packages/mcp-server/tests/mocks/cli-mock.ts that stubs all CLI command functions with realistic return data. Use dependency injection or jest.mock to swap real CLI with mocks during testing.",
            "status": "pending",
            "testStrategy": "Run the full integration test suite: verify all 9 tools are listed, each tool can be called with valid args and returns structured responses, error cases produce proper MCP error codes, and the server handles the complete lifecycle (start, process requests, shutdown). Test with the MCP SDK's Client class to simulate real AI assistant behavior. Verify response format compatibility by checking that content[0].text is parseable JSON with the expected schema. Test concurrent tool calls to verify the server handles parallelism. Measure server startup time (should be under 2 seconds). Verify the .mcp.json configuration format produces a working server connection.",
            "parentId": "undefined"
          }
        ]
      },
      {
        "id": "20",
        "title": "Create Claude Skill Package",
        "description": "Create the Claude Skill that teaches Claude the Glass methodology for instant adoption",
        "details": "Create packages/claude-skill/ with SKILL.md:\n\n1. Intent:\n   - Purpose: Enable Claude to naturally use Glass without user explanation each time\n   - Source: PRD Section 14.3\n   - Parent: distribution\n\n2. Contract:\n   - Requires:\n     * Valid skill file format\n     * MCP server available (or CLI)\n   - Guarantees on success:\n     * Claude understands Glass conventions\n     * Claude generates .glass files automatically\n     * Claude maintains manifest\n     * Claude follows intent/contract/verification pattern\n\n3. Implementation:\n   ```markdown\n   # Glass Framework Skill\n   \n   ## Overview\n   Glass is a framework for AI-first software development where AI writes all code,\n   humans review structured outlines, and a compiler guarantees correctness.\n   \n   ## Your Role\n   When working on a Glass project:\n   \n   1. **Always generate .glass files** (never raw .ts/.rs files)\n   2. **Maintain the manifest.glass** - track all requirement origins\n   3. **Write contracts for everything** - every unit needs intent + contract + implementation\n   4. **Follow the three-layer pattern**:\n      - Intent: WHY does this exist?\n      - Contract: WHAT does it guarantee?\n      - Implementation: HOW does it work?\n   \n   ## .glass File Format\n   [Include complete format spec from Section 4.1]\n   \n   ## Contract Writing Rules\n   [Include contract sections from Section 8.2]\n   \n   ## Manifest Maintenance\n   [Include manifest rules from Section 6]\n   \n   ## Using Plan Mode\n   [Include integration guidance from Section 15.6]\n   \n   ## Common Patterns\n   [Include examples from Section 17]\n   \n   ## MCP Tools Available\n   [List tools from Section 14.2 and when to use them]\n   ```\n\n4. Include concrete examples\n5. Reference CLAUDE.md content\n6. Make skill conversational and practical",
        "testStrategy": "Verify:\n- Skill file is valid format\n- Content is comprehensive\n- Examples are accurate\n- Claude understands conventions when skill is loaded\n- Claude generates valid .glass files\n- Claude maintains manifest correctly\n- Skill integrates with MCP tools\n- Test with real Claude Code session",
        "priority": "high",
        "dependencies": [
          "2",
          "19"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "21",
        "title": "Create Documentation and Examples",
        "description": "Create comprehensive documentation, tutorials, and example Glass projects",
        "details": "Create docs/ directory with:\n\n1. README.md:\n   - Quick start guide\n   - Installation instructions (CLI, MCP, Skill)\n   - 5-minute tutorial\n   - Link to full documentation\n\n2. GETTING_STARTED.md:\n   - Step-by-step tutorial\n   - Build the auth example from Section 17\n   - Explanation of each step\n   - Expected output at each stage\n\n3. CONCEPTS.md:\n   - Glass philosophy\n   - Three-layer architecture\n   - Intent system\n   - Contract system\n   - Verification system\n\n4. API_REFERENCE.md:\n   - All CLI commands with examples\n   - .glass file format specification\n   - glass.config.json options\n   - Manifest format\n\n5. MCP_INTEGRATION.md:\n   - How to configure MCP server\n   - Available tools\n   - Integration with different AI tools\n\n6. Example projects:\n   - examples/auth-system/ (from Section 17)\n   - examples/todo-api/ (simple CRUD)\n   - examples/e-commerce/ (complex, multi-module)\n\n7. Migration guide from standard TypeScript projects",
        "testStrategy": "Verify:\n- Documentation is clear and accurate\n- Tutorials can be followed end-to-end\n- Examples compile and verify successfully\n- All commands are documented\n- MCP integration guide works\n- Links are not broken\n- Code examples are tested",
        "priority": "medium",
        "dependencies": [
          "13",
          "19",
          "20"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "22",
        "title": "Create Test Suite for Core Compiler",
        "description": "Build comprehensive unit and integration tests for parser, linker, verifier, and emitter",
        "details": "Create tests/ directory:\n\n1. Unit tests for each compiler component:\n   - tests/compiler/parser.test.ts\n   - tests/compiler/linker.test.ts\n   - tests/compiler/verifier.test.ts\n   - tests/compiler/emitter.test.ts\n   - tests/compiler/view-generator.test.ts\n   - tests/compiler/manifest.test.ts\n\n2. Test fixtures:\n   - fixtures/valid-glass-files/ (various valid examples)\n   - fixtures/invalid-glass-files/ (malformed, missing sections)\n   - fixtures/auth-system/ (complete example from Section 17)\n\n3. Integration tests:\n   - tests/integration/full-pipeline.test.ts (parse → verify → emit)\n   - tests/integration/auth-example.test.ts (Section 17 example)\n\n4. Edge cases:\n   - Empty files\n   - Circular dependencies\n   - Dangling references\n   - Very large intent trees\n   - Complex contracts\n\n5. Use Jest as test framework\n6. Target 80%+ code coverage\n7. Performance benchmarks for large projects",
        "testStrategy": "Verify:\n- All tests pass\n- Code coverage >80%\n- Tests cover all success paths\n- Tests cover all failure modes\n- Integration tests verify full pipeline\n- Auth example compiles successfully\n- Performance benchmarks meet targets\n- Tests run in CI",
        "priority": "high",
        "dependencies": [
          "4",
          "5",
          "7",
          "9"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "23",
        "title": "Set Up CI/CD Pipeline",
        "description": "Configure GitHub Actions for automated testing, verification, and npm publishing",
        "details": "Create .github/workflows/:\n\n1. ci.yml - Continuous Integration:\n   ```yaml\n   name: CI\n   on: [push, pull_request]\n   jobs:\n     test:\n       runs-on: ubuntu-latest\n       steps:\n         - uses: actions/checkout@v3\n         - uses: actions/setup-node@v3\n         - run: npm install\n         - run: npm test\n         - run: npm run lint\n         - run: npm run build\n   ```\n\n2. verify-self.yml - Self-hosting verification:\n   ```yaml\n   name: Verify Glass with Glass\n   on: [push]\n   jobs:\n     self-verify:\n       runs-on: ubuntu-latest\n       steps:\n         - run: glass verify\n         - run: glass compile\n   ```\n\n3. publish.yml - NPM publishing:\n   - Triggered on version tags\n   - Publishes @glass-framework/cli\n   - Publishes @glass-framework/mcp-server\n   - Publishes @glass-framework/claude-skill\n\n4. coverage.yml - Code coverage reporting\n\n5. README badges for build status, coverage, version",
        "testStrategy": "Verify:\n- CI runs on every push\n- All tests must pass\n- Self-verification works (after ignition)\n- Publishing workflow works\n- Coverage reports are generated\n- Badges display correctly",
        "priority": "medium",
        "dependencies": [
          "22"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "24",
        "title": "Implement 'glass eject' Command",
        "description": "Build the eject command that exports clean target-language code with no Glass dependencies",
        "details": "Create src/cli/commands/eject.glass:\n\n1. Intent:\n   - Purpose: Allow users to stop using Glass and keep clean standard code\n   - Source: PRD Section 13.3 \"Eject at Any Time\"\n   - Parent: cli\n\n2. Contract:\n   - Requires:\n     * Valid Glass project\n     * Successful compilation\n   - Guarantees on success:\n     * Copies dist/ to specified directory\n     * Removes all Glass-specific files\n     * Adds README explaining ejection\n     * Code is standalone and deployable\n     * Exit code 0\n   - Guarantees on failure:\n     * No files modified\n     * Error if compilation not successful\n\n3. Implementation:\n   ```typescript\n   export async function ejectCommand(options: EjectOptions) {\n     // 1. Verify project has been compiled\n     // 2. Confirm with user (destructive operation)\n     // 3. Copy dist/ to target directory (or current)\n     // 4. Remove Glass files (.glass, manifest.glass, glass.config.json)\n     // 5. Remove .generated/ and .annotations/\n     // 6. Add EJECTED.md explaining what happened\n     // 7. Display success message\n     \n     // Confirmation prompt:\n     // \"This will remove all Glass files and leave only standard TypeScript.\n     //  The code will be standalone but you won't be able to use Glass tools.\n     //  Continue? (y/N)\"\n   }\n   ```\n\n4. Option to keep original Glass files (--keep-source)\n5. Create EJECTED.md with explanation and migration notes",
        "testStrategy": "Verify:\n- Eject command requires confirmation\n- Ejected code is standalone\n- No Glass dependencies in ejected code\n- Ejected code compiles with tsc\n- Ejected code can be deployed\n- --keep-source preserves original files\n- EJECTED.md is created\n- Works with auth example",
        "priority": "medium",
        "dependencies": [
          "9",
          "10"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "25",
        "title": "Prepare for The Ignition (Self-Hosting)",
        "description": "Convert all Glass framework source files to proper .glass format and verify Glass can compile itself",
        "details": "The Ignition milestone (Section 15.4):\n\n1. Convert all implementation files to .glass format:\n   - src/compiler/parser.ts → src/compiler/parser.glass\n   - src/compiler/linker.ts → src/compiler/linker.glass\n   - src/compiler/verifier.ts → src/compiler/verifier.glass\n   - src/compiler/emitter.ts → src/compiler/emitter.glass\n   - All CLI commands → .glass format\n   - All adapters → .glass format\n\n2. Create complete manifest.glass for Glass framework itself:\n   - Track all intents from bootstrap phase\n   - Document all origins (PRD, development decisions)\n   - Set approval policies\n\n3. Write contracts for every Glass component:\n   - Parser contract\n   - Linker contract\n   - Verifier contract\n   - Emitter contract\n   - CLI contracts\n\n4. Run self-compilation:\n   ```bash\n   cd glass-framework\n   ./bin/glass verify   # Verify Glass source with Glass compiler\n   ./bin/glass compile  # Compile Glass with Glass\n   ```\n\n5. Validation:\n   - All Glass source files verify successfully\n   - Compiled output matches current implementation\n   - Self-compiled Glass can compile itself again (idempotent)\n\n6. Document The Ignition:\n   - IGNITION.md explaining the milestone\n   - Before/after metrics\n   - Lessons learned during bootstrap",
        "testStrategy": "Verify:\n- All source files converted to .glass format\n- All files have intents and contracts\n- manifest.glass is complete\n- `glass verify` passes on Glass source\n- `glass compile` produces working compiler\n- Self-compiled Glass can compile itself\n- Bootstrap phase complete\n- Framework proves its own thesis",
        "priority": "high",
        "dependencies": [
          "13",
          "22"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Audit All Source Files and Plan .glass Conversion",
            "description": "Inventory every TypeScript source file in the Glass framework (compiler, CLI commands, adapters, types, utilities) and create a comprehensive conversion plan mapping each .ts file to its .glass equivalent with intents and contracts.",
            "dependencies": [],
            "details": "This subtask is the prerequisite analysis before any conversion work begins. Since Task 25 depends on Task 13 (glass compile) and Task 22 (test suite), all compiler components and CLI commands exist as working TypeScript at this point.\n\n1. **Full source file inventory**: Enumerate every .ts file under src/, categorized by module:\n   - src/compiler/: parser.ts, linker.ts, verifier.ts, emitter.ts (and any sub-modules like verifier/ts-ast-utils.ts, verifier/type-verifier.ts, etc.)\n   - src/cli/commands/: init.ts, verify.ts, compile.ts, views.ts, status.ts, tree.ts, trace.ts, eject.ts, annotate.ts, diff.ts, generate.ts\n   - src/cli/: framework/router (command router from Task 10)\n   - src/adapters/: typescript.ts adapter\n   - src/types/: core.ts type definitions\n   - src/compiler/: result.ts, parser-errors.ts, manifest.ts (from Tasks 3, 4, 6)\n   - Any utility modules created during bootstrap\n\n2. **Conversion mapping document**: Create a conversion-plan.md (temporary working document) that maps each source file to its target .glass format:\n   - Target .glass file path (e.g., src/compiler/parser.ts → src/compiler/parser.glass)\n   - Proposed intent (purpose, source, parent in the intent hierarchy)\n   - Proposed contract outline (key requires/guarantees based on the existing implementation)\n   - Dependencies between units (which .glass files reference which others)\n   - Conversion priority order (foundational types first, then compiler core, then CLI, then adapters)\n\n3. **Intent hierarchy design**: Design the complete intent tree for the Glass framework itself:\n   - Root intent: 'glass.framework' (purpose: 'Provide AI-first development framework with formal verification')\n   - Second level: 'glass.compiler', 'glass.cli', 'glass.adapters', 'glass.types'\n   - Third level: individual units (parser, linker, verifier, emitter, each command, etc.)\n   - Document parent-child relationships for every unit\n\n4. **Risk assessment**: Identify files that may be difficult to convert:\n   - Files with circular dependencies\n   - Files that use patterns not yet supported by the Glass parser\n   - Large files that may need to be split into multiple .glass units\n   - Shared utility code that multiple .glass units depend on",
            "status": "pending",
            "testStrategy": "Verify the inventory is complete by comparing the file list against all tasks 1-24 deliverables. Confirm every .ts file in src/ is accounted for. Validate the intent hierarchy forms a valid tree (no cycles, single root, all nodes connected). Review conversion priority order ensures foundational units are converted before dependent ones. Cross-reference the proposed contracts against existing test cases from Task 22 to ensure contracts capture tested behavior.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Write Intents and Contracts for All Compiler and CLI Components",
            "description": "Author the formal Intent and Contract sections for every Glass framework source file — all four compiler components (parser, linker, verifier, emitter), all CLI commands, the TypeScript adapter, and utility modules — following the .glass format specification from PRD Section 4.1 and 8.2.",
            "dependencies": [
              1
            ],
            "details": "Using the conversion plan from subtask 1, write complete Intent and Contract sections for every Glass framework component. These will be embedded into the .glass files during conversion (subtask 3).\n\n**Compiler component intents and contracts** (highest priority, most detailed):\n\n1. **compiler.parser** (src/compiler/parser.glass):\n   - Intent: Purpose is to parse .glass files into structured GlassFile objects. Source: PRD Section 4 & 11.1 step 1. Parent: glass.compiler.\n   - Contract requires: valid file path, file exists, file follows .glass format. Guarantees: returns valid GlassFile with all three sections extracted. Fails: FileNotFound, InvalidFormat, MissingSection. Invariants: original file never modified, parser is stateless.\n\n2. **compiler.linker** (src/compiler/linker.glass):\n   - Intent: Build and validate the intent tree from parsed .glass files. Source: PRD Section 11.1 step 2. Parent: glass.compiler.\n   - Contract requires: array of valid GlassFile objects with unique IDs. Guarantees: returns IntentTree with all relationships resolved, no circular dependencies. Fails: DanglingReference, CircularDependency, DuplicateId.\n\n3. **compiler.verifier** (src/compiler/verifier.glass):\n   - Intent: Verify implementations satisfy their contracts through static analysis. Source: PRD Section 9. Parent: glass.compiler.\n   - Contract requires: valid GlassFile with contract and implementation, TypeScript code compiles. Guarantees: returns VerificationResult with all assertions checked, each at appropriate level. Invariants: implementation not modified, verification is deterministic.\n\n4. **compiler.emitter** (src/compiler/emitter.glass):\n   - Intent: Output clean standard TypeScript from verified .glass files. Source: PRD Section 11.1 step 6. Parent: glass.compiler.\n   - Contract requires: verified GlassFile (all contracts satisfied). Guarantees: emitted TypeScript compiles with tsc, no Glass artifacts in output. Invariants: source .glass files not modified.\n\n**CLI command intents and contracts** (one per command from PRD Section 12):\n- cli.init, cli.verify, cli.compile, cli.views, cli.status, cli.tree, cli.trace, cli.annotate, cli.diff, cli.eject, cli.generate\n- Each follows the pattern: Intent references PRD Section 12, parent is glass.cli. Contract specifies valid Glass project as precondition and command-specific guarantees/exit codes.\n\n**Adapter and utility intents and contracts**:\n- adapters.typescript: Intent to translate contracts into TypeScript constructs. Contract requires valid GlassFile with language: typescript.\n- types.core: Intent to define all Glass type definitions. Contract guarantees types compile without errors and represent all PRD concepts.\n- compiler.result: Intent to provide Result<T,E> monad. Contract guarantees type safety for error handling.\n- compiler.manifest: Intent to parse and manage manifest.glass. Contract requires valid manifest format.\n\nAll contracts must follow the exact format from PRD Section 4.1: requires, guarantees (on_success/on_failure), invariants, fails, and advisories sections. Every failure mode must be explicitly named with a handling strategy.",
            "status": "pending",
            "testStrategy": "Validate each intent has all required fields (purpose, source, parent, stakeholder). Validate each contract has all mandatory sections (requires, guarantees with on_success/on_failure, invariants, fails). Cross-reference contracts against the existing test suite from Task 22 — every tested behavior should map to a contract assertion. Verify the intent hierarchy matches the design from subtask 1. Parse each intent and contract section through the Glass parser (Task 4) to confirm they are syntactically valid .glass format. Count total contract assertions and compare against Task 22 test count for coverage parity.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Convert All Source Files to .glass Format and Create manifest.glass",
            "description": "Transform every TypeScript source file into the .glass file format by wrapping existing implementation code with the authored Intent and Contract sections, rename files from .ts to .glass, create the complete manifest.glass for the Glass framework itself, and update all import paths and build configuration.",
            "dependencies": [
              2
            ],
            "details": "This is the core conversion step — assembling complete .glass files from the intents/contracts (subtask 2) and existing TypeScript implementations, then creating the framework's own manifest.\n\n**File conversion process** (for each source file):\n\n1. Create the .glass file with the three-section format from PRD Section 4.1:\n   ```\n   === Glass Unit ===\n   id: compiler.parser\n   version: 0.1.0\n   language: typescript\n\n   === Intent ===\n   [intent from subtask 2]\n\n   === Contract ===\n   [contract from subtask 2]\n\n   === Implementation ===\n   [existing TypeScript code, copied verbatim]\n   ```\n\n2. Conversion order (respecting dependencies):\n   - Phase A: Foundation — src/types/core.glass, src/compiler/result.glass, src/compiler/parser-errors.glass\n   - Phase B: Compiler core — parser.glass, linker.glass, verifier.glass (and sub-modules), emitter.glass\n   - Phase C: Infrastructure — manifest.glass manager, CLI framework/router\n   - Phase D: CLI commands — init.glass, verify.glass, compile.glass, views.glass, status.glass, tree.glass, trace.glass, annotate.glass, diff.glass, eject.glass, generate.glass\n   - Phase E: Adapters — typescript.glass adapter\n\n3. **Import path updates**: All TypeScript imports between modules must be updated to reference .glass files. The Glass compiler's emitter handles resolving .glass imports to .ts during compilation, but the source references must use .glass extensions.\n\n4. **Create manifest.glass** for the Glass framework itself:\n   ```\n   Glass Manifest: GlassFramework\n   Version: 0.1.0\n   Language: TypeScript\n   Created: [current date]\n\n   Origins:\n     PRD: \"Glass Framework Specification v0.1.0\"\n       → authored by user, [date]\n     Development: \"Bootstrap phase implementation\"\n       → Tasks 1-24 via Taskmaster MCP\n\n   Policies:\n     auto-approve: security, audit, infrastructure\n     require-approval: framework-behavior, compiler-semantics\n\n   Intent Registry:\n     user-originated: [count] intents\n     development-derived: [count] intents\n     ai-generated: [count] intents\n   ```\n   - Track all intents from the conversion plan\n   - Document all origins (PRD sections, task references)\n   - Set approval policies appropriate for a compiler framework\n\n5. **Remove original .ts files** after confirming .glass versions are complete and parseable.\n\n6. **Update build configuration**: Ensure tsconfig.json, package.json scripts, and any build tooling reference the Glass compilation pipeline (glass compile) instead of direct tsc.",
            "status": "pending",
            "testStrategy": "Parse every converted .glass file through the Glass parser (Task 4) and confirm zero parse errors. Verify manifest.glass parses correctly through the ManifestManager (Task 6). Verify the intent tree links correctly through the IntentLinker (Task 5) — no dangling references, no cycles, valid hierarchy. Run `tsc --noEmit` on the implementation sections to confirm TypeScript still compiles. Count .glass files and confirm it matches the inventory from subtask 1. Verify no orphan .ts files remain in src/. Confirm manifest.glass intent registry counts match actual .glass file count.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Run First Self-Verification and Self-Compilation (The Ignition)",
            "description": "Execute `glass verify` on all Glass framework .glass source files for the first self-verification, then run `glass compile` for the first self-compilation, fixing any contract violations or compilation failures that surface during this historic milestone.",
            "dependencies": [
              3
            ],
            "details": "This is The Ignition — the moment Glass proves its own thesis by verifying and compiling itself. This will likely be iterative as the real compiler discovers violations the CLAUDE.md proto-compiler missed.\n\n**Step 1: First self-verification** (`glass verify`):\n1. Run `./bin/glass verify` from the Glass framework root\n2. The verifier will check every .glass file's contract against its implementation\n3. Collect all verification results — expect some failures on first run\n4. Categorize failures:\n   - **Contract too strict**: The contract specifies something the implementation doesn't fully satisfy → either relax the contract or enhance the implementation\n   - **Contract too loose**: The contract doesn't capture behavior that exists → tighten the contract\n   - **Missing failure handlers**: Implementation has unhandled error paths → add handlers or declare in contract fails section\n   - **Invariant violations**: Implementation inadvertently violates a declared invariant → fix the implementation\n   - **Parse errors**: .glass file format issues → fix the file format\n5. Fix each failure iteratively:\n   - For each failing unit, determine whether to fix the contract or the implementation\n   - Prefer fixing contracts to match reality unless the implementation has a genuine bug\n   - Re-run `glass verify` after each batch of fixes\n   - Continue until all units pass verification\n\n**Step 2: First self-compilation** (`glass compile`):\n1. Run `./bin/glass compile` from the Glass framework root\n2. This runs the full pipeline: parse → link → verify → generate views → emit code\n3. Verify the emitted TypeScript in dist/ compiles with `tsc`\n4. Fix any compilation issues:\n   - Import resolution errors → fix .glass import references\n   - Missing type exports → ensure all types are properly exported\n   - Emitter edge cases → fix the emitter to handle Glass's own code patterns\n5. Confirm dist/ contains a complete, working Glass compiler as standard TypeScript\n\n**Step 3: Verify compiled output works**:\n1. Run the compiled Glass from dist/ to confirm basic functionality\n2. Execute `node dist/bin/glass --version` to confirm the compiled CLI works\n3. Run `node dist/bin/glass verify` on a test .glass file to confirm the compiled verifier works\n\n**Expected iteration**: The first run will likely surface 10-30 issues. Each fix should be documented (what failed, why, what was changed). This log becomes input for the IGNITION.md documentation in subtask 5.",
            "status": "pending",
            "testStrategy": "Success criteria: `glass verify` exits with code 0 (all contracts verified). `glass compile` exits with code 0 (all code emitted). `tsc` compiles the emitted dist/ code without errors. The compiled Glass CLI in dist/ responds to `--version` and `--help` correctly. The compiled Glass verifier can verify a test .glass file. All verification results show PROVEN or INSTRUMENTED (no FAILED). Document the iteration count (number of verify-fix cycles needed) and total issues found/fixed. Verify .generated/ views are created for all Glass framework units.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Verify Idempotency and Document The Ignition Milestone",
            "description": "Prove that the self-compiled Glass compiler can compile itself again (idempotency test), producing output identical to the first compilation, then create IGNITION.md documenting the milestone with before/after metrics and lessons learned.",
            "dependencies": [
              4
            ],
            "details": "This subtask completes The Ignition by proving idempotency (the self-compiled compiler can compile itself) and creating the historical record of this milestone.\n\n**Step 1: Idempotency verification**:\n1. Take the compiled Glass from dist/ (output of subtask 4's `glass compile`)\n2. Use the *compiled* Glass to compile the Glass source again:\n   ```bash\n   # Use the self-compiled Glass to compile itself\n   node dist/bin/glass verify   # Self-compiled Glass verifying Glass source\n   node dist/bin/glass compile  # Self-compiled Glass compiling Glass source\n   ```\n3. Compare the second compilation output with the first:\n   - Binary comparison of all emitted .ts files: `diff -r dist/ dist-second/`\n   - The outputs should be byte-identical (deterministic compilation)\n   - If differences exist, investigate and fix:\n     * Timestamps or non-deterministic elements in output → make emitter deterministic\n     * Ordering differences → stabilize sort orders in linker/emitter\n     * Missing/extra files → fix file discovery logic\n4. Run the second-generation compiled Glass on a test project to confirm it works\n5. Optionally: compile a third time to triple-confirm idempotency\n\n**Step 2: Create IGNITION.md**:\nCreate IGNITION.md at the project root documenting this historic milestone:\n\n```markdown\n# The Ignition\n\n## What Is The Ignition?\n[Explain the self-hosting milestone per PRD Section 15.4]\n\n## Timeline\n- Bootstrap started: [date]\n- First successful self-verification: [date]\n- First successful self-compilation: [date]\n- Idempotency confirmed: [date]\n\n## Before vs After\n| Metric | Before (CLAUDE.md) | After (Glass Compiler) |\n|--------|-------------------|----------------------|\n| Enforcement | Convention-based | Compiler-enforced |\n| Contract verification | Trust Claude | Formally proven |\n| Total .glass files | [count] | [count] |\n| Total contract assertions | [count] | [count] |\n| Assertions PROVEN | N/A | [count] |\n| Assertions INSTRUMENTED | N/A | [count] |\n| Advisories | N/A | [count] |\n\n## Issues Found During Ignition\n[Document each issue from subtask 4's iteration log]\n- Issue 1: [description], fixed by [change]\n- Issue 2: ...\n\n## Lessons Learned\n[What the team learned about Glass by having Glass compile itself]\n- Contracts that were too strict/loose\n- Edge cases the proto-compiler missed\n- Patterns that worked well\n- Areas needing improvement in Phase 2\n\n## Idempotency Results\n- First compilation: [stats]\n- Second compilation (self-compiled): [stats]\n- Output comparison: [identical/differences]\n\n## What Changes\n- CLAUDE.md transitions from proto-compiler to project guide\n- All future Glass development is verified by the Glass compiler\n- The framework has proven its own thesis\n```\n\n**Step 3: Update CLAUDE.md**:\n- Add a section noting The Ignition has been achieved\n- Transition CLAUDE.md role from 'proto-compiler' to 'project guide'\n- Remove enforcement language that is now handled by the compiler\n- Keep methodology documentation, coding standards, and contribution guidelines\n\n**Step 4: Update CI/CD** (coordinate with Task 23):\n- Add self-verification step to CI pipeline: `glass verify` runs on Glass source\n- Add self-compilation step: `glass compile` must succeed\n- Add idempotency check: compiled Glass compiles itself with identical output",
            "status": "pending",
            "testStrategy": "Idempotency test: run `diff -r` between first and second compilation outputs — must show zero differences. The second-generation compiled Glass must pass its own test suite (Task 22 tests executed against dist/ output). IGNITION.md exists and contains all required sections (timeline, before/after metrics, issues, lessons, idempotency results). CLAUDE.md has been updated to reflect post-Ignition status. CI pipeline includes self-verification and self-compilation steps. Run `glass verify` using the second-generation compiler on a sample project (e.g., the auth example from PRD Section 17) to confirm the self-compiled compiler works on external projects.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-02-01T19:11:08.843Z",
      "taskCount": 25,
      "completedCount": 10,
      "tags": [
        "master"
      ]
    }
  }
}